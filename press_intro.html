<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRESS. - Opening Cinematic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
        }
        
        #canvas-container {
            position: fixed;
            inset: 0;
        }
        
        canvas {
            display: block;
        }
        
        /* Start Screen */
        .start-screen {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.8s ease-out;
        }
        
        .start-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .start-text {
            font-family: 'Segoe UI', sans-serif;
            font-size: 24px;
            font-weight: 300;
            color: #3a1010;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.4; text-shadow: 0 0 20px rgba(255, 0, 0, 0.2); }
            50% { opacity: 1; text-shadow: 0 0 40px rgba(255, 0, 0, 0.5); }
        }
        
        .start-warning {
            margin-top: 40px;
            font-size: 12px;
            color: #222;
            letter-spacing: 0.3em;
        }
        
        /* Overlays */
        .overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .vignette {
            background: radial-gradient(ellipse at center, transparent 0%, transparent 50%, rgba(0,0,0,0.8) 100%);
        }
        
        .film-grain {
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
            animation: grain 0.3s steps(6) infinite;
        }
        
        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            20% { transform: translate(-2%, -2%); }
            40% { transform: translate(2%, 2%); }
            60% { transform: translate(-1%, 1%); }
            80% { transform: translate(1%, -1%); }
        }
        
        .flash-overlay {
            background: #fff;
            opacity: 0;
            transition: opacity 0.05s;
            z-index: 200;
        }
        
        .blood-overlay {
            background: radial-gradient(ellipse at center, #330000 0%, #1a0000 50%, #000 100%);
            opacity: 0;
            z-index: 150;
        }
        
        .blackout {
            background: #000;
            opacity: 0;
            z-index: 300;
        }
        
        /* Title */
        .title-container {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
        }
        
        .title-container.visible {
            opacity: 1;
        }
        
        .title {
            font-family: 'Arial Black', sans-serif;
            font-size: clamp(80px, 22vw, 350px);
            font-weight: 900;
            letter-spacing: 0.05em;
            display: flex;
        }
        
        .letter {
            display: inline-block;
            opacity: 0;
            color: #ff0000;
            text-shadow: 
                0 0 20px rgba(255, 0, 0, 0.8),
                0 0 40px rgba(255, 0, 0, 0.6),
                0 0 80px rgba(255, 0, 0, 0.4),
                0 0 120px rgba(200, 0, 0, 0.3);
            transform: translateY(-100px) scale(1.5);
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
        }
        
        .letter.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .studio {
            margin-top: 60px;
            font-size: clamp(12px, 2vw, 18px);
            color: #444;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 2s ease-out;
        }
        
        .studio.visible {
            opacity: 1;
        }
        
        .studio span {
            color: #880000;
        }
        
        .skip {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 12px;
            color: #333;
            letter-spacing: 0.2em;
            z-index: 400;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .skip.visible {
            opacity: 0.4;
        }
    </style>
</head>
<body>
    <!-- Audio -->
    <audio id="bgMusic" preload="auto"><source src="dark-80s-sci-fi-atmosphere-425528.mp3" type="audio/mpeg"></audio>
    <audio id="doorSound" preload="auto"><source src="metallic-door-shut-98740.mp3" type="audio/mpeg"></audio>
    <audio id="screamSound" preload="auto"><source src="falling-man-scream-450793.mp3" type="audio/mpeg"></audio>
    <audio id="roarSound" preload="auto"><source src="monster-roar-02-102957.mp3" type="audio/mpeg"></audio>
    
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <div class="start-text">Click to Begin</div>
        <div class="start-warning">âš  HEADPHONES RECOMMENDED</div>
    </div>
    
    <!-- Three.js Canvas -->
    <div id="canvas-container"></div>
    
    <!-- Overlays -->
    <div class="overlay vignette"></div>
    <div class="overlay film-grain"></div>
    <div class="overlay flash-overlay" id="flashOverlay"></div>
    <div class="overlay blood-overlay" id="bloodOverlay"></div>
    <div class="overlay blackout" id="blackout"></div>
    
    <!-- Title -->
    <div class="title-container" id="titleContainer">
        <div class="title">
            <span class="letter">P</span>
            <span class="letter">R</span>
            <span class="letter">E</span>
            <span class="letter">S</span>
            <span class="letter">S</span>
            <span class="letter">.</span>
        </div>
        <div class="studio" id="studio">An <span>Invariant Games</span> Production</div>
    </div>
    
    <div class="skip" id="skip">ESC TO SKIP</div>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== SETUP ====================
        const container = document.getElementById('canvas-container');
        const flashOverlay = document.getElementById('flashOverlay');
        const bloodOverlay = document.getElementById('bloodOverlay');
        const blackout = document.getElementById('blackout');
        const titleContainer = document.getElementById('titleContainer');
        const letters = document.querySelectorAll('.letter');
        const studio = document.getElementById('studio');
        const skip = document.getElementById('skip');
        
        // Audio
        const bgMusic = document.getElementById('bgMusic');
        const doorSound = document.getElementById('doorSound');
        const screamSound = document.getElementById('screamSound');
        const roarSound = document.getElementById('roarSound');
        
        bgMusic.volume = 0.7;
        doorSound.volume = 0.9;
        screamSound.volume = 0.7;
        roarSound.volume = 1.0;
        
        // Three.js Scene
        let scene, camera, renderer;
        let currentScene = null;
        let clock = new THREE.Clock();
        let introStarted = false;
        
        // Camera shake
        let shakeIntensity = 0;
        let shakeDuration = 0;
        
        // Head bob
        let headBobEnabled = false;
        let headBobIntensity = 1;
        let headBobSpeed = 1;
        let headBobTime = 0;
        
        // Initialize
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ==================== SCENE BUILDERS ====================

        // STREET SCENE (Opening kidnapping)
        function buildStreetScene() {
            clearScene();

            scene.fog = new THREE.FogExp2(0x050515, 0.02);
            scene.background = new THREE.Color(0x020208);

            // Moonlight
            const moonlight = new THREE.DirectionalLight(0x6688aa, 0.4);
            moonlight.position.set(-10, 20, -10);
            moonlight.castShadow = true;
            moonlight.shadow.mapSize.width = 2048;
            moonlight.shadow.mapSize.height = 2048;
            moonlight.shadow.camera.near = 0.5;
            moonlight.shadow.camera.far = 100;
            moonlight.shadow.camera.left = -50;
            moonlight.shadow.camera.right = 50;
            moonlight.shadow.camera.top = 50;
            moonlight.shadow.camera.bottom = -50;
            scene.add(moonlight);

            // Ambient night light
            const ambient = new THREE.AmbientLight(0x1a1a2a, 0.15);
            scene.add(ambient);

            // Road
            const roadGeo = new THREE.PlaneGeometry(12, 100);
            const roadMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.9,
                metalness: 0.1
            });
            const road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0;
            road.position.x = -3;
            road.receiveShadow = true;
            scene.add(road);

            // Road lines
            const lineGeo = new THREE.PlaneGeometry(0.2, 100);
            const lineMat = new THREE.MeshBasicMaterial({
                color: 0x888844,
                transparent: true,
                opacity: 0.6
            });
            const centerLine = new THREE.Mesh(lineGeo, lineMat);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.y = 0.01;
            centerLine.position.x = -3;
            scene.add(centerLine);

            // Sidewalk (right side where player walks)
            const sidewalkGeo = new THREE.PlaneGeometry(3, 100);
            const sidewalkMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.95,
                metalness: 0
            });
            const sidewalk = new THREE.Mesh(sidewalkGeo, sidewalkMat);
            sidewalk.rotation.x = -Math.PI / 2;
            sidewalk.position.y = 0.02;
            sidewalk.position.x = 2.5;
            sidewalk.receiveShadow = true;
            scene.add(sidewalk);

            // Sidewalk (left side)
            const sidewalkLeft = new THREE.Mesh(sidewalkGeo, sidewalkMat);
            sidewalkLeft.rotation.x = -Math.PI / 2;
            sidewalkLeft.position.y = 0.02;
            sidewalkLeft.position.x = -8.5;
            sidewalkLeft.receiveShadow = true;
            scene.add(sidewalkLeft);

            // Buildings on right side
            const buildingMat = new THREE.MeshStandardMaterial({
                color: 0x1a1520,
                roughness: 0.8,
                metalness: 0.1
            });

            const windowMat = new THREE.MeshStandardMaterial({
                color: 0x3a3020,
                emissive: 0x4a4020,
                emissiveIntensity: 0.3,
                roughness: 0.2,
                metalness: 0.3
            });

            // Create buildings along the street
            for (let z = -40; z < 20; z += 12) {
                // Right side building
                const height = 8 + Math.random() * 6;
                const buildingGeo = new THREE.BoxGeometry(4, height, 10);
                const building = new THREE.Mesh(buildingGeo, buildingMat);
                building.position.set(6, height / 2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);

                // Windows for right building
                for (let floor = 0; floor < Math.floor(height / 3); floor++) {
                    for (let w = 0; w < 3; w++) {
                        if (Math.random() > 0.3) {
                            const windowGeo = new THREE.PlaneGeometry(0.8, 1.2);
                            const window = new THREE.Mesh(windowGeo, windowMat);
                            window.position.set(4.01, 2 + floor * 3, z - 3 + w * 3);
                            window.rotation.y = -Math.PI / 2;
                            scene.add(window);

                            // Some window lights
                            if (Math.random() > 0.7) {
                                const windowLight = new THREE.PointLight(0xffaa44, 0.3, 5);
                                windowLight.position.set(4.5, 2 + floor * 3, z - 3 + w * 3);
                                scene.add(windowLight);
                            }
                        }
                    }
                }

                // Left side building
                const leftHeight = 7 + Math.random() * 5;
                const leftBuildingGeo = new THREE.BoxGeometry(4, leftHeight, 10);
                const leftBuilding = new THREE.Mesh(leftBuildingGeo, buildingMat);
                leftBuilding.position.set(-12, leftHeight / 2, z + 6);
                leftBuilding.castShadow = true;
                leftBuilding.receiveShadow = true;
                scene.add(leftBuilding);

                // Windows for left building
                for (let floor = 0; floor < Math.floor(leftHeight / 3); floor++) {
                    for (let w = 0; w < 3; w++) {
                        if (Math.random() > 0.3) {
                            const windowGeo = new THREE.PlaneGeometry(0.8, 1.2);
                            const window = new THREE.Mesh(windowGeo, windowMat);
                            window.position.set(-10.01, 2 + floor * 3, z + 3 + w * 3);
                            window.rotation.y = Math.PI / 2;
                            scene.add(window);

                            if (Math.random() > 0.7) {
                                const windowLight = new THREE.PointLight(0xffaa44, 0.3, 5);
                                windowLight.position.set(-10.5, 2 + floor * 3, z + 3 + w * 3);
                                scene.add(windowLight);
                            }
                        }
                    }
                }
            }

            // Street lamps
            const lampPostMat = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.6,
                metalness: 0.4
            });

            for (let z = -30; z < 10; z += 15) {
                // Right sidewalk lamp
                const lampPost = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 5, 8), lampPostMat);
                lampPost.position.set(3.5, 2.5, z);
                lampPost.castShadow = true;
                scene.add(lampPost);

                // Lamp head
                const lampHead = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.15, 0.3, 8), lampPostMat);
                lampHead.position.set(3.5, 5.2, z);
                scene.add(lampHead);

                // Lamp light
                const lampLight = new THREE.PointLight(0xffaa66, 1.5, 20);
                lampLight.position.set(3.5, 5, z);
                lampLight.castShadow = true;
                scene.add(lampLight);

                // Lamp glow
                const glowGeo = new THREE.SphereGeometry(0.18, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xffcc88,
                    transparent: true,
                    opacity: 0.8
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.set(3.5, 5, z);
                scene.add(glow);
            }

            // Create the van (initially behind player)
            const van = createVan();
            van.position.set(-5, 0, 25);
            van.rotation.y = Math.PI;
            scene.add(van);
            scene.userData.van = van;

            // Create kidnappers (initially hidden in van)
            const kidnapper1 = createKidnapper();
            kidnapper1.position.set(-4, 0, 0);
            kidnapper1.visible = false;
            scene.add(kidnapper1);
            scene.userData.kidnapper1 = kidnapper1;

            const kidnapper2 = createKidnapper();
            kidnapper2.position.set(-6, 0, 0);
            kidnapper2.visible = false;
            scene.add(kidnapper2);
            scene.userData.kidnapper2 = kidnapper2;

            camera.position.set(2.5, 1.7, 0);
            camera.rotation.set(0, 0, 0);
            camera.lookAt(2.5, 1.7, -10);
        }

        // Create van model
        function createVan() {
            const vanGroup = new THREE.Group();

            // Main body
            const bodyGeo = new THREE.BoxGeometry(2.5, 2, 5);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.7,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.5;
            body.castShadow = true;
            vanGroup.add(body);

            // Cabin
            const cabinGeo = new THREE.BoxGeometry(2.5, 1.5, 2.2);
            const cabin = new THREE.Mesh(cabinGeo, bodyMat);
            cabin.position.set(0, 2.75, 1.6);
            cabin.castShadow = true;
            vanGroup.add(cabin);

            // Windshield
            const windshieldGeo = new THREE.BoxGeometry(2.3, 1.2, 0.1);
            const windshieldMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a1a,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.8
            });
            const windshield = new THREE.Mesh(windshieldGeo, windshieldMat);
            windshield.position.set(0, 2.8, 2.65);
            windshield.rotation.x = -0.1;
            vanGroup.add(windshield);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wheelMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.8
            });

            const wheelPositions = [
                { x: -1.1, z: 1.8 },
                { x: 1.1, z: 1.8 },
                { x: -1.1, z: -1.8 },
                { x: 1.1, z: -1.8 }
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, 0.4, pos.z);
                wheel.castShadow = true;
                vanGroup.add(wheel);
            });

            // Headlights
            const headlightGeo = new THREE.BoxGeometry(0.3, 0.2, 0.1);
            const headlightMat = new THREE.MeshStandardMaterial({
                color: 0xffeeaa,
                emissive: 0xffeeaa,
                emissiveIntensity: 0.5
            });

            const leftHeadlight = new THREE.Mesh(headlightGeo, headlightMat);
            leftHeadlight.position.set(-0.8, 1.2, 2.55);
            vanGroup.add(leftHeadlight);

            const rightHeadlight = new THREE.Mesh(headlightGeo, headlightMat);
            rightHeadlight.position.set(0.8, 1.2, 2.55);
            vanGroup.add(rightHeadlight);

            // Headlight beams
            const leftBeam = new THREE.SpotLight(0xffeeaa, 2, 30, Math.PI / 6, 0.5);
            leftBeam.position.set(-0.8, 1.2, 2.6);
            leftBeam.target.position.set(-0.8, 0, 20);
            leftBeam.castShadow = true;
            vanGroup.add(leftBeam);
            vanGroup.add(leftBeam.target);

            const rightBeam = new THREE.SpotLight(0xffeeaa, 2, 30, Math.PI / 6, 0.5);
            rightBeam.position.set(0.8, 1.2, 2.6);
            rightBeam.target.position.set(0.8, 0, 20);
            rightBeam.castShadow = true;
            vanGroup.add(rightBeam);
            vanGroup.add(rightBeam.target);

            // Side door (sliding door on right side)
            const doorGeo = new THREE.BoxGeometry(0.1, 1.6, 1.8);
            const doorMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.6,
                metalness: 0.3
            });
            const slidingDoor = new THREE.Mesh(doorGeo, doorMat);
            slidingDoor.position.set(1.3, 1.5, -0.5);
            slidingDoor.castShadow = true;
            vanGroup.add(slidingDoor);
            vanGroup.userData.door = slidingDoor;

            return vanGroup;
        }

        // Create kidnapper model
        function createKidnapper() {
            const kidnapper = new THREE.Group();

            // Dark clothing material
            const clothingMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.9,
                metalness: 0
            });

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.4, 12);
            const body = new THREE.Mesh(bodyGeo, clothingMat);
            body.position.y = 1.2;
            body.castShadow = true;
            kidnapper.add(body);

            // Head with balaclava
            const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.85
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.1;
            head.castShadow = true;
            kidnapper.add(head);

            // Eyes (barely visible)
            const eyeMat = new THREE.MeshBasicMaterial({
                color: 0x1a1510,
                transparent: true,
                opacity: 0.6
            });

            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
            leftEye.position.set(-0.08, 2.12, -0.22);
            kidnapper.add(leftEye);

            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
            rightEye.position.set(0.08, 2.12, -0.22);
            kidnapper.add(rightEye);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.12, 0.1, 1, 8);

            const leftArm = new THREE.Mesh(armGeo, clothingMat);
            leftArm.position.set(-0.5, 1.2, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            kidnapper.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, clothingMat);
            rightArm.position.set(0.5, 1.2, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            kidnapper.add(rightArm);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.15, 0.13, 1, 8);

            const leftLeg = new THREE.Mesh(legGeo, clothingMat);
            leftLeg.position.set(-0.2, 0.5, 0);
            leftLeg.castShadow = true;
            kidnapper.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, clothingMat);
            rightLeg.position.set(0.2, 0.5, 0);
            rightLeg.castShadow = true;
            kidnapper.add(rightLeg);

            return kidnapper;
        }

        // HALLWAY SCENE
        function buildHallwayScene() {
            clearScene();
            
            scene.fog = new THREE.Fog(0x0a0505, 1, 25);
            scene.background = new THREE.Color(0x050202);
            
            // Ambient light
            const ambient = new THREE.AmbientLight(0x1a0a0a, 0.3);
            scene.add(ambient);
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(6, 50);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x1a0808,
                roughness: 0.9,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Floor tiles pattern
            const tileGeo = new THREE.PlaneGeometry(5.8, 49.8);
            const tileMat = new THREE.MeshStandardMaterial({
                color: 0x150606,
                roughness: 0.85,
                metalness: 0.05
            });
            const tiles = new THREE.Mesh(tileGeo, tileMat);
            tiles.rotation.x = -Math.PI / 2;
            tiles.position.y = 0.001;
            scene.add(tiles);
            
            // Ceiling
            const ceilingGeo = new THREE.PlaneGeometry(6, 50);
            const ceilingMat = new THREE.MeshStandardMaterial({
                color: 0x0a0404,
                roughness: 0.95,
                metalness: 0
            });
            const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 3.5;
            scene.add(ceiling);
            
            // Walls
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0x120606,
                roughness: 0.9,
                metalness: 0.05
            });
            
            const wallGeo = new THREE.PlaneGeometry(50, 3.5);
            
            const leftWall = new THREE.Mesh(wallGeo, wallMat);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-3, 1.75, 0);
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(wallGeo, wallMat);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(3, 1.75, 0);
            scene.add(rightWall);
            
            // Wall panels
            const panelGeo = new THREE.BoxGeometry(0.1, 2, 1.2);
            const panelMat = new THREE.MeshStandardMaterial({
                color: 0x0d0404,
                roughness: 0.85
            });
            
            for (let z = -20; z < 0; z += 4) {
                const leftPanel = new THREE.Mesh(panelGeo, panelMat);
                leftPanel.position.set(-2.9, 1.5, z);
                scene.add(leftPanel);
                
                const rightPanel = new THREE.Mesh(panelGeo, panelMat);
                rightPanel.position.set(2.9, 1.5, z);
                scene.add(rightPanel);
            }
            
            // Ceiling lights
            for (let z = -20; z < 0; z += 5) {
                const light = new THREE.PointLight(0xff4420, 0.8, 8);
                light.position.set(0, 3.3, z);
                light.castShadow = true;
                scene.add(light);
                
                // Light fixture
                const fixtureGeo = new THREE.BoxGeometry(0.8, 0.1, 0.3);
                const fixtureMat = new THREE.MeshStandardMaterial({
                    color: 0x331100,
                    emissive: 0x441100,
                    emissiveIntensity: 0.5
                });
                const fixture = new THREE.Mesh(fixtureGeo, fixtureMat);
                fixture.position.set(0, 3.45, z);
                scene.add(fixture);
            }
            
            // THE DOOR
            const doorGroup = new THREE.Group();
            doorGroup.position.set(0, 0, -22);
            
            // Door frame
            const frameMat = new THREE.MeshStandardMaterial({
                color: 0x1a0808,
                roughness: 0.8
            });
            
            const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.8, 0.2), frameMat);
            frameLeft.position.set(-0.9, 1.4, 0);
            doorGroup.add(frameLeft);
            
            const frameRight = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.8, 0.2), frameMat);
            frameRight.position.set(0.9, 1.4, 0);
            doorGroup.add(frameRight);
            
            const frameTop = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 0.2), frameMat);
            frameTop.position.set(0, 2.85, 0);
            doorGroup.add(frameTop);
            
            // Door itself
            const doorMat = new THREE.MeshStandardMaterial({
                color: 0x2a1210,
                roughness: 0.7,
                metalness: 0.1
            });
            const door = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.6, 0.08), doorMat);
            door.position.set(0, 1.35, 0);
            door.castShadow = true;
            doorGroup.add(door);
            
            // Door handle
            const handleMat = new THREE.MeshStandardMaterial({
                color: 0x4a3020,
                roughness: 0.5,
                metalness: 0.6
            });
            const handle = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 16), handleMat);
            handle.position.set(0.6, 1.3, 0.06);
            doorGroup.add(handle);
            
            // Light under door
            const doorLight = new THREE.PointLight(0xff5520, 2, 5);
            doorLight.position.set(0, 0.1, 0.5);
            doorGroup.add(doorLight);
            
            // Light glow plane
            const glowGeo = new THREE.PlaneGeometry(1.4, 0.08);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xff6030,
                transparent: true,
                opacity: 0.9
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.rotation.x = -Math.PI / 2;
            glow.position.set(0, 0.01, 0.15);
            doorGroup.add(glow);
            
            scene.add(doorGroup);
            scene.userData.door = doorGroup;
            
            // CHASER (shadow entity behind player)
            const chaserGroup = new THREE.Group();
            chaserGroup.position.set(0, 0, 8);
            
            // Body
            const chaserBodyGeo = new THREE.CylinderGeometry(0.5, 0.7, 2.5, 8);
            const chaserBodyMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.95
            });
            const chaserBody = new THREE.Mesh(chaserBodyGeo, chaserBodyMat);
            chaserBody.position.y = 1.25;
            chaserGroup.add(chaserBody);
            
            // Head
            const chaserHeadGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const chaserHead = new THREE.Mesh(chaserHeadGeo, chaserBodyMat);
            chaserHead.position.y = 2.7;
            chaserGroup.add(chaserHead);
            
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), eyeMat);
            leftEye.position.set(-0.15, 2.75, -0.35);
            chaserGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), eyeMat);
            rightEye.position.set(0.15, 2.75, -0.35);
            chaserGroup.add(rightEye);
            
            // Eye lights
            const eyeLight = new THREE.PointLight(0xff0000, 0.5, 3);
            eyeLight.position.set(0, 2.75, -0.3);
            chaserGroup.add(eyeLight);
            
            scene.add(chaserGroup);
            scene.userData.chaser = chaserGroup;
            
            camera.position.set(0, 1.7, 0);
            camera.lookAt(0, 1.7, -22);
        }
        
        // FOREST SCENE
        function buildForestScene() {
            clearScene();
            
            scene.fog = new THREE.FogExp2(0x020504, 0.08);
            scene.background = new THREE.Color(0x010302);
            
            // Dim moonlight
            const moonlight = new THREE.DirectionalLight(0x334455, 0.15);
            moonlight.position.set(5, 10, -5);
            scene.add(moonlight);
            
            // Ambient
            const ambient = new THREE.AmbientLight(0x0a1510, 0.2);
            scene.add(ambient);
            
            // Ground
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x0a1508,
                roughness: 1,
                metalness: 0
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Trees
            const treeMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a08,
                roughness: 0.9
            });
            
            const foliageMat = new THREE.MeshStandardMaterial({
                color: 0x0a1a0a,
                roughness: 0.95
            });
            
            const treePositions = [
                // Close trees (around player)
                { x: -4, z: -3, scale: 1.2 },
                { x: 5, z: -2, scale: 1.3 },
                { x: -3, z: -8, scale: 1.1 },
                { x: 4, z: -6, scale: 1.0 },
                { x: -6, z: -5, scale: 1.4 },
                { x: 7, z: -4, scale: 1.2 },
                // Medium distance
                { x: -8, z: -12, scale: 1.0 },
                { x: 9, z: -10, scale: 1.1 },
                { x: -2, z: -15, scale: 0.9 },
                { x: 3, z: -14, scale: 1.0 },
                { x: -10, z: -8, scale: 1.3 },
                { x: 11, z: -7, scale: 1.2 },
                // Far trees
                { x: -5, z: -22, scale: 0.8 },
                { x: 6, z: -20, scale: 0.85 },
                { x: -12, z: -18, scale: 0.9 },
                { x: 13, z: -16, scale: 0.95 },
                { x: 0, z: -25, scale: 0.7 },
                // Behind player
                { x: -4, z: 5, scale: 1.1 },
                { x: 5, z: 6, scale: 1.2 },
                { x: -7, z: 8, scale: 1.0 },
                { x: 8, z: 7, scale: 1.15 },
            ];
            
            treePositions.forEach(pos => {
                const tree = new THREE.Group();
                
                // Trunk
                const trunkHeight = 4 + Math.random() * 3;
                const trunkGeo = new THREE.CylinderGeometry(0.15 * pos.scale, 0.25 * pos.scale, trunkHeight * pos.scale, 8);
                const trunk = new THREE.Mesh(trunkGeo, treeMat);
                trunk.position.y = (trunkHeight * pos.scale) / 2;
                trunk.castShadow = true;
                tree.add(trunk);
                
                // Foliage layers
                for (let i = 0; i < 3; i++) {
                    const size = (1.8 - i * 0.4) * pos.scale;
                    const foliageGeo = new THREE.ConeGeometry(size, size * 1.5, 8);
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.y = (trunkHeight * pos.scale) + i * 1.2 * pos.scale;
                    foliage.castShadow = true;
                    tree.add(foliage);
                }
                
                tree.position.set(pos.x, 0, pos.z);
                scene.add(tree);
            });
            
            // Watching eyes in darkness
            const eyePositions = [
                { x: -6, y: 1.5, z: -10 },
                { x: 8, y: 1.8, z: -8 },
                { x: -10, y: 1.3, z: -15 },
                { x: 12, y: 1.6, z: -12 },
                { x: -3, y: 2.0, z: -20 },
            ];
            
            eyePositions.forEach(pos => {
                const eyeGroup = new THREE.Group();
                
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff2200 });
                
                const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
                leftEye.position.x = -0.1;
                eyeGroup.add(leftEye);
                
                const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
                rightEye.position.x = 0.1;
                eyeGroup.add(rightEye);
                
                const eyeLight = new THREE.PointLight(0xff2200, 0.3, 2);
                eyeGroup.add(eyeLight);
                
                eyeGroup.position.set(pos.x, pos.y, pos.z);
                eyeGroup.lookAt(0, 1.7, 0);
                scene.add(eyeGroup);
            });
            
            // Entity (far behind, watching)
            const entityGroup = createEntity();
            entityGroup.position.set(0, 0, 15);
            entityGroup.scale.set(0.8, 0.8, 0.8);
            scene.add(entityGroup);
            scene.userData.entity = entityGroup;
            
            camera.position.set(0, 1.7, 0);
            camera.lookAt(0, 1.7, -15);
        }
        
        // Create entity model
        function createEntity() {
            const entity = new THREE.Group();
            
            const bodyMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.98
            });
            
            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.6, 0.9, 3, 12);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.5;
            entity.add(body);
            
            // Head
            const headGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.y = 3.2;
            head.scale.set(1, 1.2, 1);
            entity.add(head);
            
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), eyeMat);
            leftEye.position.set(-0.2, 3.3, -0.4);
            entity.add(leftEye);
            
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), eyeMat);
            rightEye.position.set(0.2, 3.3, -0.4);
            entity.add(rightEye);
            
            // Eye glow
            const eyeGlow = new THREE.PointLight(0xff0000, 1, 5);
            eyeGlow.position.set(0, 3.3, -0.3);
            entity.add(eyeGlow);
            
            // Mouth
            const mouthGeo = new THREE.BoxGeometry(0.4, 0.25, 0.15);
            const mouthMat = new THREE.MeshBasicMaterial({ color: 0x100000 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 3.0, -0.45);
            entity.add(mouth);
            
            // Teeth
            const toothMat = new THREE.MeshBasicMaterial({ color: 0xccccaa });
            for (let i = -3; i <= 3; i++) {
                const tooth = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.12, 4), toothMat);
                tooth.position.set(i * 0.05, 2.92, -0.45);
                tooth.rotation.x = Math.PI;
                entity.add(tooth);
            }
            
            // Arms/tendrils
            const armMat = new THREE.MeshBasicMaterial({
                color: 0x050505,
                transparent: true,
                opacity: 0.9
            });
            
            for (let i = 0; i < 4; i++) {
                const armGeo = new THREE.CylinderGeometry(0.08, 0.15, 1.5, 8);
                const arm = new THREE.Mesh(armGeo, armMat);
                const angle = (i - 1.5) * 0.4;
                const side = i < 2 ? -1 : 1;
                arm.position.set(side * 0.7, 1.8, 0);
                arm.rotation.z = side * 0.5;
                entity.add(arm);
            }
            
            return entity;
        }
        
        // LOOKBACK SCENE (entity close up)
        function buildLookbackScene() {
            clearScene();
            
            scene.fog = new THREE.Fog(0x010201, 1, 15);
            scene.background = new THREE.Color(0x010101);
            
            const ambient = new THREE.AmbientLight(0x0a0505, 0.1);
            scene.add(ambient);
            
            // Entity right in front
            const entity = createEntity();
            entity.position.set(0, 0, -3);
            entity.scale.set(1.5, 1.5, 1.5);
            scene.add(entity);
            scene.userData.entity = entity;
            
            // Dramatic red backlight
            const backlight = new THREE.PointLight(0xff0000, 0.5, 10);
            backlight.position.set(0, 3, -5);
            scene.add(backlight);
            
            camera.position.set(0, 1.7, 0);
            camera.lookAt(0, 2.5, -3);
        }
        
        // GROUND VIEW (after falling)
        function buildGroundScene() {
            clearScene();
            
            scene.fog = new THREE.FogExp2(0x020302, 0.1);
            scene.background = new THREE.Color(0x010201);
            
            const ambient = new THREE.AmbientLight(0x0a1008, 0.15);
            scene.add(ambient);
            
            // Ground (close up)
            const groundGeo = new THREE.PlaneGeometry(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x0a1208,
                roughness: 1
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            
            // Debris
            const debrisMat = new THREE.MeshStandardMaterial({
                color: 0x151a12,
                roughness: 0.95
            });
            
            for (let i = 0; i < 15; i++) {
                const debris = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1 + Math.random() * 0.2, 8, 8),
                    debrisMat
                );
                debris.position.set(
                    (Math.random() - 0.5) * 4,
                    0.05,
                    (Math.random() - 0.5) * 4
                );
                debris.scale.y = 0.3;
                scene.add(debris);
            }
            
            // Entity looming above
            const entity = createEntity();
            entity.position.set(0, 0, -2);
            entity.scale.set(2, 2, 2);
            scene.add(entity);
            scene.userData.entity = entity;
            
            // Looking up from ground
            camera.position.set(0, 0.3, 0);
            camera.lookAt(0, 3, -2);
        }
        
        // TITLE SCENE
        function buildTitleScene() {
            clearScene();
            
            scene.background = new THREE.Color(0x000000);
            scene.fog = null;
            
            // Subtle red ambient
            const ambient = new THREE.AmbientLight(0x1a0000, 0.2);
            scene.add(ambient);
            
            // Red point light
            const redLight = new THREE.PointLight(0xff0000, 0.3, 20);
            redLight.position.set(0, 2, 5);
            scene.add(redLight);
            
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
        }
        
        function clearScene() {
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            scene.userData = {};
        }
        
        // ==================== ANIMATION ====================
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Head bob
            if (headBobEnabled) {
                headBobTime += delta * headBobSpeed * 10;
                const bobY = Math.sin(headBobTime * 2) * 0.08 * headBobIntensity;
                const bobX = Math.sin(headBobTime) * 0.03 * headBobIntensity;
                const tiltZ = Math.sin(headBobTime) * 0.01 * headBobIntensity;
                
                camera.position.y += bobY * delta * 10;
                camera.position.x += bobX * delta * 10;
                camera.rotation.z = tiltZ;
            }
            
            // Camera shake
            if (shakeDuration > 0) {
                shakeDuration -= delta;
                const intensity = shakeIntensity * (shakeDuration / 0.5);
                camera.position.x += (Math.random() - 0.5) * intensity * 0.3;
                camera.position.y += (Math.random() - 0.5) * intensity * 0.2;
                camera.rotation.z += (Math.random() - 0.5) * intensity * 0.02;
            }
            
            renderer.render(scene, camera);
        }
        
        // ==================== EFFECTS ====================
        
        function shake(intensity, duration) {
            shakeIntensity = intensity;
            shakeDuration = duration;
        }
        
        function flash(duration = 100) {
            flashOverlay.style.opacity = '1';
            setTimeout(() => {
                flashOverlay.style.transition = `opacity ${duration}ms ease-out`;
                flashOverlay.style.opacity = '0';
                setTimeout(() => flashOverlay.style.transition = '', duration);
            }, 30);
        }
        
        function triggerBlackout(duration) {
            blackout.style.opacity = '1';
            setTimeout(() => {
                blackout.style.transition = `opacity ${duration}ms`;
                blackout.style.opacity = '0';
            }, duration / 2);
        }
        
        // ==================== SCENES ====================

        async function runIntro() {
            skip.classList.add('visible');

            // SCENE 0: Kidnapping (0-9s)
            await runKidnappingScene();

            // SCENE 1: Hallway chase (0-5s)
            await runHallwayChase();
            
            // SCENE 2: Forest run (5-10s)
            await runForestRun();
            
            // SCENE 3: Look back (10-12.5s)
            await runLookback();
            
            // SCENE 4: Fall (12.5-14s)
            await runFall();
            
            // SCENE 5: Entity attack (14-17s)
            await runEntityAttack();
            
            // SCENE 6: Blood/Death (17-21s)
            await runBloodScene();
            
            // SCENE 7: Title (21-32s)
            await runTitleReveal();
        }

        function runKidnappingScene() {
            return new Promise(resolve => {
                buildStreetScene();

                const van = scene.userData.van;
                const kidnapper1 = scene.userData.kidnapper1;
                const kidnapper2 = scene.userData.kidnapper2;
                const door = van.userData.door;

                // Enable head bob for walking
                headBobEnabled = true;
                headBobIntensity = 0.8;
                headBobSpeed = 1;

                const duration = 9000;
                const startTime = Date.now();

                function animateKidnapping() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Phase 1: Walking forward (0-2s)
                    if (elapsed < 2000) {
                        const walkProgress = elapsed / 2000;
                        camera.position.z = -walkProgress * 3;
                        camera.lookAt(2.5, 1.7, camera.position.z - 10);
                    }

                    // Phase 2: Van approaches from behind (2-5s)
                    if (elapsed >= 2000 && elapsed < 5000) {
                        const vanProgress = (elapsed - 2000) / 3000;
                        const eased = vanProgress * vanProgress;

                        // Van drives up from behind and moves alongside
                        van.position.z = 25 - eased * 28;
                        van.position.x = -5 + eased * 2;

                        // Player continues walking but slower
                        camera.position.z = -3 - (elapsed - 2000) / 3000 * 2;
                        camera.lookAt(2.5, 1.7, camera.position.z - 10);

                        // Player starts to notice and look toward van
                        if (elapsed > 4000) {
                            const lookProgress = (elapsed - 4000) / 1000;
                            camera.lookAt(
                                2.5 - lookProgress * 5,
                                1.7,
                                camera.position.z - 5
                            );
                        }
                    }

                    // Phase 3: Van stops, door opens (5-6s)
                    if (elapsed >= 5000 && elapsed < 6000) {
                        headBobEnabled = false;
                        const doorProgress = (elapsed - 5000) / 1000;

                        // Stop van completely
                        van.position.z = -3;
                        van.position.x = -3;

                        // Player stops walking
                        camera.position.z = -5;

                        // Look at van
                        camera.lookAt(-3, 1.5, -3);

                        // Slide door open
                        door.position.x = 1.3 + doorProgress * 1.5;
                    }

                    // Phase 4: Kidnappers jump out (6-7s)
                    if (elapsed >= 6000 && elapsed < 7000) {
                        const jumpProgress = (elapsed - 6000) / 1000;
                        const eased = jumpProgress * jumpProgress;

                        // Make kidnappers visible
                        kidnapper1.visible = true;
                        kidnapper2.visible = true;

                        // Kidnappers jump out from van
                        kidnapper1.position.set(
                            -3 + eased * 4,
                            Math.sin(jumpProgress * Math.PI) * 0.3,
                            -3 + eased * 1
                        );

                        kidnapper2.position.set(
                            -3 + eased * 5,
                            Math.sin(jumpProgress * Math.PI) * 0.3,
                            -3.5 + eased * 0.5
                        );

                        // Both face toward player
                        kidnapper1.lookAt(camera.position.x, 1, camera.position.z);
                        kidnapper2.lookAt(camera.position.x, 1, camera.position.z);
                    }

                    // Phase 5: Kidnappers grab player (7-8.5s)
                    if (elapsed >= 7000 && elapsed < 8500) {
                        const grabProgress = (elapsed - 7000) / 1500;
                        const eased = grabProgress * grabProgress * grabProgress;

                        // Kidnappers rush toward player
                        kidnapper1.position.set(
                            1 + eased * 1.5,
                            0,
                            -2 - eased * 3
                        );

                        kidnapper2.position.set(
                            1 + eased * 1.5,
                            0,
                            -3.5 - eased * 1.5
                        );

                        kidnapper1.lookAt(camera.position);
                        kidnapper2.lookAt(camera.position);

                        // Camera struggle - violent shaking and rotation
                        if (elapsed > 7500) {
                            const struggleProgress = (elapsed - 7500) / 1000;
                            camera.rotation.x = Math.sin(struggleProgress * Math.PI * 4) * 0.3;
                            camera.rotation.z = Math.sin(struggleProgress * Math.PI * 3) * 0.4;
                            camera.position.y = 1.7 - struggleProgress * 0.5;

                            // Shake effect
                            shake(3, 0.1);
                        }
                    }

                    // Phase 6: Pulled into van / blackout (8.5-9s)
                    if (elapsed >= 8500) {
                        const blackoutProgress = (elapsed - 8500) / 500;

                        // Camera pulled toward van
                        camera.position.x = 2.5 - blackoutProgress * 5.5;
                        camera.position.z = -5 + blackoutProgress * 2;
                        camera.position.y = 1.7 - blackoutProgress * 0.7;
                        camera.rotation.x = blackoutProgress * Math.PI * 0.3;
                        camera.rotation.z = blackoutProgress * Math.PI * 0.2;

                        // Fade to black
                        blackout.style.transition = 'opacity 0.5s';
                        blackout.style.opacity = blackoutProgress;
                    }

                    if (progress < 1) {
                        requestAnimationFrame(animateKidnapping);
                    }
                }

                animateKidnapping();

                // Final blackout
                setTimeout(() => {
                    blackout.style.opacity = '1';
                }, 8500);

                // Transition message (optional)
                setTimeout(() => {
                    headBobEnabled = false;
                    camera.rotation.set(0, 0, 0);
                    resolve();
                }, duration);
            });
        }

        function runHallwayChase() {
            return new Promise(resolve => {
                buildHallwayScene();

                // Fade in from black (waking up after kidnapping)
                blackout.style.transition = 'opacity 1.5s ease-out';
                blackout.style.opacity = '0';

                headBobEnabled = true;
                headBobIntensity = 1.2;
                headBobSpeed = 1.3;
                
                const door = scene.userData.door;
                const chaser = scene.userData.chaser;
                
                // Animate toward door
                const startZ = camera.position.z;
                const endZ = -19;
                const duration = 4500;
                const startTime = Date.now();
                
                function animateHallway() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 2);
                    
                    camera.position.z = startZ + (endZ - startZ) * eased;
                    camera.lookAt(0, 1.7, -22);
                    
                    // Chaser follows and gets closer
                    if (chaser) {
                        chaser.position.z = camera.position.z + 8 - progress * 4;
                    }
                    
                    // Door light intensifies as we approach
                    if (door) {
                        const doorLight = door.children.find(c => c.type === 'PointLight');
                        if (doorLight) {
                            doorLight.intensity = 2 + progress * 3;
                        }
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateHallway);
                    }
                }
                animateHallway();
                
                // Door burst - cleaner transition
                setTimeout(() => {
                    headBobEnabled = false;
                    doorSound.play();
                    
                    // Flash white as we hit the door
                    flashOverlay.style.transition = 'none';
                    flashOverlay.style.opacity = '1';
                    
                    shake(2.5, 0.5);
                }, 4200);
                
                // Hold white flash briefly, then fade through to forest
                setTimeout(() => {
                    // Keep flash white during scene transition
                    flashOverlay.style.transition = 'opacity 0.6s ease-out';
                }, 4400);
                
                setTimeout(() => {
                    // Fade flash out (forest will be built underneath)
                    flashOverlay.style.opacity = '0';
                }, 4600);
                
                setTimeout(resolve, 4500);
            });
        }
        
        function runForestRun() {
            return new Promise(resolve => {
                buildForestScene();
                
                // Slight delay before starting run (disorientation moment)
                setTimeout(() => {
                    headBobEnabled = true;
                    headBobIntensity = 1.5;
                    headBobSpeed = 1.5;
                }, 300);
                
                // Run through forest
                const duration = 4700;
                const startTime = Date.now();
                
                function animateForest() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    camera.position.z = -progress * 15;
                    camera.lookAt(0, 1.7, camera.position.z - 10);
                    
                    // Entity in background follows
                    const entity = scene.userData.entity;
                    if (entity) {
                        entity.position.z = 15 - progress * 5;
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateForest);
                    }
                }
                animateForest();
                
                // Panic blackouts (confusion in the forest)
                setTimeout(() => triggerBlackout(80), 1200);
                setTimeout(() => triggerBlackout(100), 2500);
                setTimeout(() => triggerBlackout(70), 3800);
                
                setTimeout(resolve, 5000);
            });
        }
        
        function runLookback() {
            return new Promise(resolve => {
                buildLookbackScene();
                headBobEnabled = false;
                
                const entity = scene.userData.entity;
                
                // Entity approaches
                setTimeout(() => {
                    roarSound.play();
                    if (entity) {
                        const startZ = entity.position.z;
                        const endZ = -1.5;
                        const duration = 800;
                        const startTime = Date.now();
                        
                        function lungeAnim() {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            const eased = progress * progress;
                            
                            entity.position.z = startZ + (endZ - startZ) * eased;
                            
                            if (progress < 1) {
                                requestAnimationFrame(lungeAnim);
                            }
                        }
                        lungeAnim();
                    }
                    shake(1.5, 0.8);
                }, 1500);
                
                setTimeout(resolve, 2500);
            });
        }
        
        function runFall() {
            return new Promise(resolve => {
                screamSound.play();
                
                // Tumbling camera
                const duration = 1500;
                const startTime = Date.now();
                
                function tumble() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    camera.rotation.x = progress * Math.PI * 0.5;
                    camera.rotation.z = Math.sin(progress * Math.PI * 3) * 0.5;
                    camera.position.y = 1.7 - progress * 1.4;
                    
                    if (progress < 1) {
                        requestAnimationFrame(tumble);
                    }
                }
                tumble();
                
                // Impact
                setTimeout(() => {
                    flash(200);
                    shake(3, 0.6);
                }, 1300);
                
                setTimeout(resolve, 1500);
            });
        }
        
        function runEntityAttack() {
            return new Promise(resolve => {
                buildGroundScene();
                
                const entity = scene.userData.entity;
                
                // Entity emerges
                if (entity) {
                    entity.visible = false;
                    setTimeout(() => {
                        entity.visible = true;
                    }, 800);
                }
                
                // Entity lunges at camera
                setTimeout(() => {
                    roarSound.currentTime = 0;
                    roarSound.play();
                    shake(2.5, 0.6);
                    
                    if (entity) {
                        const duration = 600;
                        const startTime = Date.now();
                        const startZ = entity.position.z;
                        const startScale = entity.scale.x;
                        
                        function attackAnim() {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            const eased = progress * progress * progress;
                            
                            entity.position.z = startZ + 3 * eased;
                            const scale = startScale + 3 * eased;
                            entity.scale.set(scale, scale, scale);
                            
                            if (progress < 1) {
                                requestAnimationFrame(attackAnim);
                            }
                        }
                        attackAnim();
                    }
                }, 2000);
                
                setTimeout(() => {
                    flash(80);
                }, 2500);
                
                setTimeout(resolve, 2600);
            });
        }
        
        function runBloodScene() {
            return new Promise(resolve => {
                // Red flash
                bloodOverlay.style.transition = 'opacity 0.2s';
                bloodOverlay.style.opacity = '1';
                
                // Fade to black
                setTimeout(() => {
                    blackout.style.transition = 'opacity 1.5s ease-in';
                    blackout.style.opacity = '1';
                }, 2500);
                
                setTimeout(() => {
                    bloodOverlay.style.opacity = '0';
                    blackout.style.transition = 'opacity 1s';
                    blackout.style.opacity = '0';
                    resolve();
                }, 4000);
            });
        }
        
        function runTitleReveal() {
            return new Promise(resolve => {
                buildTitleScene();
                titleContainer.classList.add('visible');
                
                // Letters slam down
                const timings = [500, 700, 900, 1100, 1300, 1800];
                letters.forEach((letter, i) => {
                    setTimeout(() => {
                        letter.classList.add('visible');
                        shake(1.2, 0.25);
                    }, timings[i]);
                });
                
                // Studio credit
                setTimeout(() => {
                    studio.classList.add('visible');
                }, 3000);
                
                // Final fade
                setTimeout(() => {
                    blackout.style.transition = 'opacity 3s ease-in';
                    blackout.style.opacity = '1';
                }, 10000);
                
                setTimeout(resolve, 13000);
            });
        }
        
        // ==================== START ====================
        
        document.getElementById('startScreen').addEventListener('click', startIntro);
        document.addEventListener('keydown', (e) => {
            if (!introStarted && (e.key === 'Enter' || e.key === ' ')) startIntro();
            if (introStarted && e.key === 'Escape') skipIntro();
        });
        
        function startIntro() {
            if (introStarted) return;
            introStarted = true;
            
            document.getElementById('startScreen').classList.add('hidden');
            
            // Start music immediately
            bgMusic.currentTime = 0;
            bgMusic.play();
            
            runIntro();
        }
        
        function skipIntro() {
            bgMusic.pause();
            blackout.style.transition = 'opacity 0.5s';
            blackout.style.opacity = '1';
            setTimeout(() => {
                location.reload();
            }, 500);
        }
        
        // Initialize
        init();
    </script>
</body>
</html>
