<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRESS. - Opening Cinematic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
        }
        
        #canvas-container {
            position: fixed;
            inset: 0;
        }
        
        canvas {
            display: block;
        }
        
        /* Start Screen */
        .start-screen {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.8s ease-out;
        }
        
        .start-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .start-text {
            font-family: 'Segoe UI', sans-serif;
            font-size: 24px;
            font-weight: 300;
            color: #3a1010;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.4; text-shadow: 0 0 20px rgba(255, 0, 0, 0.2); }
            50% { opacity: 1; text-shadow: 0 0 40px rgba(255, 0, 0, 0.5); }
        }
        
        .start-warning {
            margin-top: 40px;
            font-size: 12px;
            color: #222;
            letter-spacing: 0.3em;
        }
        
        /* Overlays */
        .overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .vignette {
            background: radial-gradient(ellipse at center, transparent 0%, transparent 50%, rgba(0,0,0,0.8) 100%);
        }
        
        .film-grain {
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
            animation: grain 0.3s steps(6) infinite;
        }
        
        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            20% { transform: translate(-2%, -2%); }
            40% { transform: translate(2%, 2%); }
            60% { transform: translate(-1%, 1%); }
            80% { transform: translate(1%, -1%); }
        }
        
        .flash-overlay {
            background: #fff;
            opacity: 0;
            transition: opacity 0.05s;
            z-index: 200;
        }
        
        .blood-overlay {
            background: radial-gradient(ellipse at center, #330000 0%, #1a0000 50%, #000 100%);
            opacity: 0;
            z-index: 150;
        }
        
        .blackout {
            background: #000;
            opacity: 0;
            z-index: 300;
        }
        
        /* Title */
        .title-container {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
        }
        
        .title-container.visible {
            opacity: 1;
        }
        
        .title {
            font-family: 'Arial Black', sans-serif;
            font-size: clamp(80px, 22vw, 350px);
            font-weight: 900;
            letter-spacing: 0.05em;
            display: flex;
        }
        
        .letter {
            display: inline-block;
            opacity: 0;
            color: #ff0000;
            text-shadow: 
                0 0 20px rgba(255, 0, 0, 0.8),
                0 0 40px rgba(255, 0, 0, 0.6),
                0 0 80px rgba(255, 0, 0, 0.4),
                0 0 120px rgba(200, 0, 0, 0.3);
            transform: translateY(-100px) scale(1.5);
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
        }
        
        .letter.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .studio {
            margin-top: 60px;
            font-size: clamp(12px, 2vw, 18px);
            color: #444;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 2s ease-out;
        }
        
        .studio.visible {
            opacity: 1;
        }
        
        .studio span {
            color: #880000;
        }
        
        .skip {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 12px;
            color: #333;
            letter-spacing: 0.2em;
            z-index: 400;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .skip.visible {
            opacity: 0.4;
        }
    </style>
</head>
<body>
    <!-- Audio -->
    <audio id="bgMusic" preload="auto"><source src="dark-80s-sci-fi-atmosphere-425528.mp3" type="audio/mpeg"></audio>
    <audio id="doorSound" preload="auto"><source src="metallic-door-shut-98740.mp3" type="audio/mpeg"></audio>
    <audio id="screamSound" preload="auto"><source src="falling-man-scream-450793.mp3" type="audio/mpeg"></audio>
    <audio id="roarSound" preload="auto"><source src="monster-roar-02-102957.mp3" type="audio/mpeg"></audio>
    
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <div class="start-text">Click to Begin</div>
        <div class="start-warning">âš  HEADPHONES RECOMMENDED</div>
    </div>
    
    <!-- Three.js Canvas -->
    <div id="canvas-container"></div>
    
    <!-- Overlays -->
    <div class="overlay vignette"></div>
    <div class="overlay film-grain"></div>
    <div class="overlay flash-overlay" id="flashOverlay"></div>
    <div class="overlay blood-overlay" id="bloodOverlay"></div>
    <div class="overlay blackout" id="blackout"></div>
    
    <!-- Title -->
    <div class="title-container" id="titleContainer">
        <div class="title">
            <span class="letter">P</span>
            <span class="letter">R</span>
            <span class="letter">E</span>
            <span class="letter">S</span>
            <span class="letter">S</span>
            <span class="letter">.</span>
        </div>
        <div class="studio" id="studio">An <span>Invariant Games</span> Production</div>
    </div>
    
    <div class="skip" id="skip">ESC TO SKIP</div>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== SETUP ====================
        const container = document.getElementById('canvas-container');
        const flashOverlay = document.getElementById('flashOverlay');
        const bloodOverlay = document.getElementById('bloodOverlay');
        const blackout = document.getElementById('blackout');
        const titleContainer = document.getElementById('titleContainer');
        const letters = document.querySelectorAll('.letter');
        const studio = document.getElementById('studio');
        const skip = document.getElementById('skip');
        
        // Audio
        const bgMusic = document.getElementById('bgMusic');
        const doorSound = document.getElementById('doorSound');
        const screamSound = document.getElementById('screamSound');
        const roarSound = document.getElementById('roarSound');
        
        bgMusic.volume = 0.7;
        doorSound.volume = 0.9;
        screamSound.volume = 0.7;
        roarSound.volume = 1.0;
        
        // Three.js Scene
        let scene, camera, renderer;
        let currentScene = null;
        let clock = new THREE.Clock();
        let introStarted = false;
        
        // Camera shake
        let shakeIntensity = 0;
        let shakeDuration = 0;
        
        // Head bob
        let headBobEnabled = false;
        let headBobIntensity = 1;
        let headBobSpeed = 1;
        let headBobTime = 0;
        
        // Initialize
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ==================== SCENE BUILDERS ====================
        
        // HALLWAY SCENE
        function buildHallwayScene() {
            clearScene();
            
            scene.fog = new THREE.Fog(0x0a0505, 1, 25);
            scene.background = new THREE.Color(0x050202);
            
            // Ambient light
            const ambient = new THREE.AmbientLight(0x1a0a0a, 0.3);
            scene.add(ambient);
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(6, 50);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x1a0808,
                roughness: 0.9,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Floor tiles pattern
            const tileGeo = new THREE.PlaneGeometry(5.8, 49.8);
            const tileMat = new THREE.MeshStandardMaterial({
                color: 0x150606,
                roughness: 0.85,
                metalness: 0.05
            });
            const tiles = new THREE.Mesh(tileGeo, tileMat);
            tiles.rotation.x = -Math.PI / 2;
            tiles.position.y = 0.001;
            scene.add(tiles);
            
            // Ceiling
            const ceilingGeo = new THREE.PlaneGeometry(6, 50);
            const ceilingMat = new THREE.MeshStandardMaterial({
                color: 0x0a0404,
                roughness: 0.95,
                metalness: 0
            });
            const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 3.5;
            scene.add(ceiling);
            
            // Walls
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0x120606,
                roughness: 0.9,
                metalness: 0.05
            });
            
            const wallGeo = new THREE.PlaneGeometry(50, 3.5);
            
            const leftWall = new THREE.Mesh(wallGeo, wallMat);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-3, 1.75, 0);
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(wallGeo, wallMat);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(3, 1.75, 0);
            scene.add(rightWall);
            
            // Wall panels
            const panelGeo = new THREE.BoxGeometry(0.1, 2, 1.2);
            const panelMat = new THREE.MeshStandardMaterial({
                color: 0x0d0404,
                roughness: 0.85
            });
            
            for (let z = -20; z < 0; z += 4) {
                const leftPanel = new THREE.Mesh(panelGeo, panelMat);
                leftPanel.position.set(-2.9, 1.5, z);
                scene.add(leftPanel);
                
                const rightPanel = new THREE.Mesh(panelGeo, panelMat);
                rightPanel.position.set(2.9, 1.5, z);
                scene.add(rightPanel);
            }
            
            // Ceiling lights
            for (let z = -20; z < 0; z += 5) {
                const light = new THREE.PointLight(0xff4420, 0.8, 8);
                light.position.set(0, 3.3, z);
                light.castShadow = true;
                scene.add(light);
                
                // Light fixture
                const fixtureGeo = new THREE.BoxGeometry(0.8, 0.1, 0.3);
                const fixtureMat = new THREE.MeshStandardMaterial({
                    color: 0x331100,
                    emissive: 0x441100,
                    emissiveIntensity: 0.5
                });
                const fixture = new THREE.Mesh(fixtureGeo, fixtureMat);
                fixture.position.set(0, 3.45, z);
                scene.add(fixture);
            }
            
            // THE DOOR
            const doorGroup = new THREE.Group();
            doorGroup.position.set(0, 0, -22);
            
            // Door frame
            const frameMat = new THREE.MeshStandardMaterial({
                color: 0x1a0808,
                roughness: 0.8
            });
            
            const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.8, 0.2), frameMat);
            frameLeft.position.set(-0.9, 1.4, 0);
            doorGroup.add(frameLeft);
            
            const frameRight = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.8, 0.2), frameMat);
            frameRight.position.set(0.9, 1.4, 0);
            doorGroup.add(frameRight);
            
            const frameTop = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 0.2), frameMat);
            frameTop.position.set(0, 2.85, 0);
            doorGroup.add(frameTop);
            
            // Door itself
            const doorMat = new THREE.MeshStandardMaterial({
                color: 0x2a1210,
                roughness: 0.7,
                metalness: 0.1
            });
            const door = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.6, 0.08), doorMat);
            door.position.set(0, 1.35, 0);
            door.castShadow = true;
            doorGroup.add(door);
            
            // Door handle
            const handleMat = new THREE.MeshStandardMaterial({
                color: 0x4a3020,
                roughness: 0.5,
                metalness: 0.6
            });
            const handle = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 16), handleMat);
            handle.position.set(0.6, 1.3, 0.06);
            doorGroup.add(handle);
            
            // Light under door
            const doorLight = new THREE.PointLight(0xff5520, 2, 5);
            doorLight.position.set(0, 0.1, 0.5);
            doorGroup.add(doorLight);
            
            // Light glow plane
            const glowGeo = new THREE.PlaneGeometry(1.4, 0.08);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xff6030,
                transparent: true,
                opacity: 0.9
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.rotation.x = -Math.PI / 2;
            glow.position.set(0, 0.01, 0.15);
            doorGroup.add(glow);
            
            scene.add(doorGroup);
            scene.userData.door = doorGroup;
            
            // CHASER (shadow entity behind player)
            const chaserGroup = new THREE.Group();
            chaserGroup.position.set(0, 0, 8);
            
            // Body
            const chaserBodyGeo = new THREE.CylinderGeometry(0.5, 0.7, 2.5, 8);
            const chaserBodyMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.95
            });
            const chaserBody = new THREE.Mesh(chaserBodyGeo, chaserBodyMat);
            chaserBody.position.y = 1.25;
            chaserGroup.add(chaserBody);
            
            // Head
            const chaserHeadGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const chaserHead = new THREE.Mesh(chaserHeadGeo, chaserBodyMat);
            chaserHead.position.y = 2.7;
            chaserGroup.add(chaserHead);
            
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), eyeMat);
            leftEye.position.set(-0.15, 2.75, -0.35);
            chaserGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), eyeMat);
            rightEye.position.set(0.15, 2.75, -0.35);
            chaserGroup.add(rightEye);
            
            // Eye lights
            const eyeLight = new THREE.PointLight(0xff0000, 0.5, 3);
            eyeLight.position.set(0, 2.75, -0.3);
            chaserGroup.add(eyeLight);
            
            scene.add(chaserGroup);
            scene.userData.chaser = chaserGroup;
            
            camera.position.set(0, 1.7, 0);
            camera.lookAt(0, 1.7, -22);
        }
        
        // FOREST SCENE
        function buildForestScene() {
            clearScene();
            
            scene.fog = new THREE.FogExp2(0x020504, 0.08);
            scene.background = new THREE.Color(0x010302);
            
            // Dim moonlight
            const moonlight = new THREE.DirectionalLight(0x334455, 0.15);
            moonlight.position.set(5, 10, -5);
            scene.add(moonlight);
            
            // Ambient
            const ambient = new THREE.AmbientLight(0x0a1510, 0.2);
            scene.add(ambient);
            
            // Ground
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x0a1508,
                roughness: 1,
                metalness: 0
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Trees
            const treeMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a08,
                roughness: 0.9
            });
            
            const foliageMat = new THREE.MeshStandardMaterial({
                color: 0x0a1a0a,
                roughness: 0.95
            });
            
            const treePositions = [
                // Close trees (around player)
                { x: -4, z: -3, scale: 1.2 },
                { x: 5, z: -2, scale: 1.3 },
                { x: -3, z: -8, scale: 1.1 },
                { x: 4, z: -6, scale: 1.0 },
                { x: -6, z: -5, scale: 1.4 },
                { x: 7, z: -4, scale: 1.2 },
                // Medium distance
                { x: -8, z: -12, scale: 1.0 },
                { x: 9, z: -10, scale: 1.1 },
                { x: -2, z: -15, scale: 0.9 },
                { x: 3, z: -14, scale: 1.0 },
                { x: -10, z: -8, scale: 1.3 },
                { x: 11, z: -7, scale: 1.2 },
                // Far trees
                { x: -5, z: -22, scale: 0.8 },
                { x: 6, z: -20, scale: 0.85 },
                { x: -12, z: -18, scale: 0.9 },
                { x: 13, z: -16, scale: 0.95 },
                { x: 0, z: -25, scale: 0.7 },
                // Behind player
                { x: -4, z: 5, scale: 1.1 },
                { x: 5, z: 6, scale: 1.2 },
                { x: -7, z: 8, scale: 1.0 },
                { x: 8, z: 7, scale: 1.15 },
            ];
            
            treePositions.forEach(pos => {
                const tree = new THREE.Group();
                
                // Trunk
                const trunkHeight = 4 + Math.random() * 3;
                const trunkGeo = new THREE.CylinderGeometry(0.15 * pos.scale, 0.25 * pos.scale, trunkHeight * pos.scale, 8);
                const trunk = new THREE.Mesh(trunkGeo, treeMat);
                trunk.position.y = (trunkHeight * pos.scale) / 2;
                trunk.castShadow = true;
                tree.add(trunk);
                
                // Foliage layers
                for (let i = 0; i < 3; i++) {
                    const size = (1.8 - i * 0.4) * pos.scale;
                    const foliageGeo = new THREE.ConeGeometry(size, size * 1.5, 8);
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.y = (trunkHeight * pos.scale) + i * 1.2 * pos.scale;
                    foliage.castShadow = true;
                    tree.add(foliage);
                }
                
                tree.position.set(pos.x, 0, pos.z);
                scene.add(tree);
            });
            
            // Watching eyes in darkness
            const eyePositions = [
                { x: -6, y: 1.5, z: -10 },
                { x: 8, y: 1.8, z: -8 },
                { x: -10, y: 1.3, z: -15 },
                { x: 12, y: 1.6, z: -12 },
                { x: -3, y: 2.0, z: -20 },
            ];
            
            eyePositions.forEach(pos => {
                const eyeGroup = new THREE.Group();
                
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff2200 });
                
                const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
                leftEye.position.x = -0.1;
                eyeGroup.add(leftEye);
                
                const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
                rightEye.position.x = 0.1;
                eyeGroup.add(rightEye);
                
                const eyeLight = new THREE.PointLight(0xff2200, 0.3, 2);
                eyeGroup.add(eyeLight);
                
                eyeGroup.position.set(pos.x, pos.y, pos.z);
                eyeGroup.lookAt(0, 1.7, 0);
                scene.add(eyeGroup);
            });
            
            // Entity (far behind, watching)
            const entityGroup = createEntity();
            entityGroup.position.set(0, 0, 15);
            entityGroup.scale.set(0.8, 0.8, 0.8);
            scene.add(entityGroup);
            scene.userData.entity = entityGroup;
            
            camera.position.set(0, 1.7, 0);
            camera.lookAt(0, 1.7, -15);
        }
        
        // Create entity model
        function createEntity() {
            const entity = new THREE.Group();
            
            const bodyMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.98
            });
            
            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.6, 0.9, 3, 12);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.5;
            entity.add(body);
            
            // Head
            const headGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.y = 3.2;
            head.scale.set(1, 1.2, 1);
            entity.add(head);
            
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), eyeMat);
            leftEye.position.set(-0.2, 3.3, -0.4);
            entity.add(leftEye);
            
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), eyeMat);
            rightEye.position.set(0.2, 3.3, -0.4);
            entity.add(rightEye);
            
            // Eye glow
            const eyeGlow = new THREE.PointLight(0xff0000, 1, 5);
            eyeGlow.position.set(0, 3.3, -0.3);
            entity.add(eyeGlow);
            
            // Mouth
            const mouthGeo = new THREE.BoxGeometry(0.4, 0.25, 0.15);
            const mouthMat = new THREE.MeshBasicMaterial({ color: 0x100000 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 3.0, -0.45);
            entity.add(mouth);
            
            // Teeth
            const toothMat = new THREE.MeshBasicMaterial({ color: 0xccccaa });
            for (let i = -3; i <= 3; i++) {
                const tooth = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.12, 4), toothMat);
                tooth.position.set(i * 0.05, 2.92, -0.45);
                tooth.rotation.x = Math.PI;
                entity.add(tooth);
            }
            
            // Arms/tendrils
            const armMat = new THREE.MeshBasicMaterial({
                color: 0x050505,
                transparent: true,
                opacity: 0.9
            });
            
            for (let i = 0; i < 4; i++) {
                const armGeo = new THREE.CylinderGeometry(0.08, 0.15, 1.5, 8);
                const arm = new THREE.Mesh(armGeo, armMat);
                const angle = (i - 1.5) * 0.4;
                const side = i < 2 ? -1 : 1;
                arm.position.set(side * 0.7, 1.8, 0);
                arm.rotation.z = side * 0.5;
                entity.add(arm);
            }
            
            return entity;
        }
        
        // LOOKBACK SCENE (entity close up)
        function buildLookbackScene() {
            clearScene();
            
            scene.fog = new THREE.Fog(0x010201, 1, 15);
            scene.background = new THREE.Color(0x010101);
            
            const ambient = new THREE.AmbientLight(0x0a0505, 0.1);
            scene.add(ambient);
            
            // Entity right in front
            const entity = createEntity();
            entity.position.set(0, 0, -3);
            entity.scale.set(1.5, 1.5, 1.5);
            scene.add(entity);
            scene.userData.entity = entity;
            
            // Dramatic red backlight
            const backlight = new THREE.PointLight(0xff0000, 0.5, 10);
            backlight.position.set(0, 3, -5);
            scene.add(backlight);
            
            camera.position.set(0, 1.7, 0);
            camera.lookAt(0, 2.5, -3);
        }
        
        // GROUND VIEW (after falling)
        function buildGroundScene() {
            clearScene();
            
            scene.fog = new THREE.FogExp2(0x020302, 0.1);
            scene.background = new THREE.Color(0x010201);
            
            const ambient = new THREE.AmbientLight(0x0a1008, 0.15);
            scene.add(ambient);
            
            // Ground (close up)
            const groundGeo = new THREE.PlaneGeometry(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x0a1208,
                roughness: 1
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            
            // Debris
            const debrisMat = new THREE.MeshStandardMaterial({
                color: 0x151a12,
                roughness: 0.95
            });
            
            for (let i = 0; i < 15; i++) {
                const debris = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1 + Math.random() * 0.2, 8, 8),
                    debrisMat
                );
                debris.position.set(
                    (Math.random() - 0.5) * 4,
                    0.05,
                    (Math.random() - 0.5) * 4
                );
                debris.scale.y = 0.3;
                scene.add(debris);
            }
            
            // Entity looming above
            const entity = createEntity();
            entity.position.set(0, 0, -2);
            entity.scale.set(2, 2, 2);
            scene.add(entity);
            scene.userData.entity = entity;
            
            // Looking up from ground
            camera.position.set(0, 0.3, 0);
            camera.lookAt(0, 3, -2);
        }
        
        // TITLE SCENE
        function buildTitleScene() {
            clearScene();
            
            scene.background = new THREE.Color(0x000000);
            scene.fog = null;
            
            // Subtle red ambient
            const ambient = new THREE.AmbientLight(0x1a0000, 0.2);
            scene.add(ambient);
            
            // Red point light
            const redLight = new THREE.PointLight(0xff0000, 0.3, 20);
            redLight.position.set(0, 2, 5);
            scene.add(redLight);
            
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
        }
        
        function clearScene() {
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            scene.userData = {};
        }
        
        // ==================== ANIMATION ====================
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Head bob
            if (headBobEnabled) {
                headBobTime += delta * headBobSpeed * 10;
                const bobY = Math.sin(headBobTime * 2) * 0.08 * headBobIntensity;
                const bobX = Math.sin(headBobTime) * 0.03 * headBobIntensity;
                const tiltZ = Math.sin(headBobTime) * 0.01 * headBobIntensity;
                
                camera.position.y += bobY * delta * 10;
                camera.position.x += bobX * delta * 10;
                camera.rotation.z = tiltZ;
            }
            
            // Camera shake
            if (shakeDuration > 0) {
                shakeDuration -= delta;
                const intensity = shakeIntensity * (shakeDuration / 0.5);
                camera.position.x += (Math.random() - 0.5) * intensity * 0.3;
                camera.position.y += (Math.random() - 0.5) * intensity * 0.2;
                camera.rotation.z += (Math.random() - 0.5) * intensity * 0.02;
            }
            
            renderer.render(scene, camera);
        }
        
        // ==================== EFFECTS ====================
        
        function shake(intensity, duration) {
            shakeIntensity = intensity;
            shakeDuration = duration;
        }
        
        function flash(duration = 100) {
            flashOverlay.style.opacity = '1';
            setTimeout(() => {
                flashOverlay.style.transition = `opacity ${duration}ms ease-out`;
                flashOverlay.style.opacity = '0';
                setTimeout(() => flashOverlay.style.transition = '', duration);
            }, 30);
        }
        
        function triggerBlackout(duration) {
            blackout.style.opacity = '1';
            setTimeout(() => {
                blackout.style.transition = `opacity ${duration}ms`;
                blackout.style.opacity = '0';
            }, duration / 2);
        }
        
        // ==================== SCENES ====================
        
        async function runIntro() {
            skip.classList.add('visible');
            
            // SCENE 1: Hallway chase (0-5s)
            await runHallwayChase();
            
            // SCENE 2: Forest run (5-10s)
            await runForestRun();
            
            // SCENE 3: Look back (10-12.5s)
            await runLookback();
            
            // SCENE 4: Fall (12.5-14s)
            await runFall();
            
            // SCENE 5: Entity attack (14-17s)
            await runEntityAttack();
            
            // SCENE 6: Blood/Death (17-21s)
            await runBloodScene();
            
            // SCENE 7: Title (21-32s)
            await runTitleReveal();
        }
        
        function runHallwayChase() {
            return new Promise(resolve => {
                buildHallwayScene();
                
                headBobEnabled = true;
                headBobIntensity = 1.2;
                headBobSpeed = 1.3;
                
                const door = scene.userData.door;
                const chaser = scene.userData.chaser;
                
                // Animate toward door
                const startZ = camera.position.z;
                const endZ = -19;
                const duration = 4500;
                const startTime = Date.now();
                
                function animateHallway() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 2);
                    
                    camera.position.z = startZ + (endZ - startZ) * eased;
                    camera.lookAt(0, 1.7, -22);
                    
                    // Chaser follows and gets closer
                    if (chaser) {
                        chaser.position.z = camera.position.z + 8 - progress * 4;
                    }
                    
                    // Door light intensifies as we approach
                    if (door) {
                        const doorLight = door.children.find(c => c.type === 'PointLight');
                        if (doorLight) {
                            doorLight.intensity = 2 + progress * 3;
                        }
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateHallway);
                    }
                }
                animateHallway();
                
                // Door burst - cleaner transition
                setTimeout(() => {
                    headBobEnabled = false;
                    doorSound.play();
                    
                    // Flash white as we hit the door
                    flashOverlay.style.transition = 'none';
                    flashOverlay.style.opacity = '1';
                    
                    shake(2.5, 0.5);
                }, 4200);
                
                // Hold white flash briefly, then fade through to forest
                setTimeout(() => {
                    // Keep flash white during scene transition
                    flashOverlay.style.transition = 'opacity 0.6s ease-out';
                }, 4400);
                
                setTimeout(() => {
                    // Fade flash out (forest will be built underneath)
                    flashOverlay.style.opacity = '0';
                }, 4600);
                
                setTimeout(resolve, 4500);
            });
        }
        
        function runForestRun() {
            return new Promise(resolve => {
                buildForestScene();
                
                // Slight delay before starting run (disorientation moment)
                setTimeout(() => {
                    headBobEnabled = true;
                    headBobIntensity = 1.5;
                    headBobSpeed = 1.5;
                }, 300);
                
                // Run through forest
                const duration = 4700;
                const startTime = Date.now();
                
                function animateForest() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    camera.position.z = -progress * 15;
                    camera.lookAt(0, 1.7, camera.position.z - 10);
                    
                    // Entity in background follows
                    const entity = scene.userData.entity;
                    if (entity) {
                        entity.position.z = 15 - progress * 5;
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateForest);
                    }
                }
                animateForest();
                
                // Panic blackouts (confusion in the forest)
                setTimeout(() => triggerBlackout(80), 1200);
                setTimeout(() => triggerBlackout(100), 2500);
                setTimeout(() => triggerBlackout(70), 3800);
                
                setTimeout(resolve, 5000);
            });
        }
        
        function runLookback() {
            return new Promise(resolve => {
                buildLookbackScene();
                headBobEnabled = false;
                
                const entity = scene.userData.entity;
                
                // Entity approaches
                setTimeout(() => {
                    roarSound.play();
                    if (entity) {
                        const startZ = entity.position.z;
                        const endZ = -1.5;
                        const duration = 800;
                        const startTime = Date.now();
                        
                        function lungeAnim() {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            const eased = progress * progress;
                            
                            entity.position.z = startZ + (endZ - startZ) * eased;
                            
                            if (progress < 1) {
                                requestAnimationFrame(lungeAnim);
                            }
                        }
                        lungeAnim();
                    }
                    shake(1.5, 0.8);
                }, 1500);
                
                setTimeout(resolve, 2500);
            });
        }
        
        function runFall() {
            return new Promise(resolve => {
                screamSound.play();
                
                // Tumbling camera
                const duration = 1500;
                const startTime = Date.now();
                
                function tumble() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    camera.rotation.x = progress * Math.PI * 0.5;
                    camera.rotation.z = Math.sin(progress * Math.PI * 3) * 0.5;
                    camera.position.y = 1.7 - progress * 1.4;
                    
                    if (progress < 1) {
                        requestAnimationFrame(tumble);
                    }
                }
                tumble();
                
                // Impact
                setTimeout(() => {
                    flash(200);
                    shake(3, 0.6);
                }, 1300);
                
                setTimeout(resolve, 1500);
            });
        }
        
        function runEntityAttack() {
            return new Promise(resolve => {
                buildGroundScene();
                
                const entity = scene.userData.entity;
                
                // Entity emerges
                if (entity) {
                    entity.visible = false;
                    setTimeout(() => {
                        entity.visible = true;
                    }, 800);
                }
                
                // Entity lunges at camera
                setTimeout(() => {
                    roarSound.currentTime = 0;
                    roarSound.play();
                    shake(2.5, 0.6);
                    
                    if (entity) {
                        const duration = 600;
                        const startTime = Date.now();
                        const startZ = entity.position.z;
                        const startScale = entity.scale.x;
                        
                        function attackAnim() {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            const eased = progress * progress * progress;
                            
                            entity.position.z = startZ + 3 * eased;
                            const scale = startScale + 3 * eased;
                            entity.scale.set(scale, scale, scale);
                            
                            if (progress < 1) {
                                requestAnimationFrame(attackAnim);
                            }
                        }
                        attackAnim();
                    }
                }, 2000);
                
                setTimeout(() => {
                    flash(80);
                }, 2500);
                
                setTimeout(resolve, 2600);
            });
        }
        
        function runBloodScene() {
            return new Promise(resolve => {
                // Red flash
                bloodOverlay.style.transition = 'opacity 0.2s';
                bloodOverlay.style.opacity = '1';
                
                // Fade to black
                setTimeout(() => {
                    blackout.style.transition = 'opacity 1.5s ease-in';
                    blackout.style.opacity = '1';
                }, 2500);
                
                setTimeout(() => {
                    bloodOverlay.style.opacity = '0';
                    blackout.style.transition = 'opacity 1s';
                    blackout.style.opacity = '0';
                    resolve();
                }, 4000);
            });
        }
        
        function runTitleReveal() {
            return new Promise(resolve => {
                buildTitleScene();
                titleContainer.classList.add('visible');
                
                // Letters slam down
                const timings = [500, 700, 900, 1100, 1300, 1800];
                letters.forEach((letter, i) => {
                    setTimeout(() => {
                        letter.classList.add('visible');
                        shake(1.2, 0.25);
                    }, timings[i]);
                });
                
                // Studio credit
                setTimeout(() => {
                    studio.classList.add('visible');
                }, 3000);
                
                // Final fade
                setTimeout(() => {
                    blackout.style.transition = 'opacity 3s ease-in';
                    blackout.style.opacity = '1';
                }, 10000);
                
                setTimeout(resolve, 13000);
            });
        }
        
        // ==================== START ====================
        
        document.getElementById('startScreen').addEventListener('click', startIntro);
        document.addEventListener('keydown', (e) => {
            if (!introStarted && (e.key === 'Enter' || e.key === ' ')) startIntro();
            if (introStarted && e.key === 'Escape') skipIntro();
        });
        
        function startIntro() {
            if (introStarted) return;
            introStarted = true;
            
            document.getElementById('startScreen').classList.add('hidden');
            
            // Start music immediately
            bgMusic.currentTime = 0;
            bgMusic.play();
            
            runIntro();
        }
        
        function skipIntro() {
            bgMusic.pause();
            blackout.style.transition = 'opacity 0.5s';
            blackout.style.opacity = '1';
            setTimeout(() => {
                location.reload();
            }, 500);
        }
        
        // Initialize
        init();
    </script>
</body>
</html>
