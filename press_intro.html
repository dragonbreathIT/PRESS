<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRESS. - Opening Cinematic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
        }
        
        #canvas-container {
            position: fixed;
            inset: 0;
        }
        
        canvas {
            display: block;
        }
        
        /* Start Screen */
        .start-screen {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.8s ease-out;
        }
        
        .start-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .start-text {
            font-family: 'Segoe UI', sans-serif;
            font-size: 24px;
            font-weight: 300;
            color: #3a1010;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.4; text-shadow: 0 0 20px rgba(255, 0, 0, 0.2); }
            50% { opacity: 1; text-shadow: 0 0 40px rgba(255, 0, 0, 0.5); }
        }
        
        .start-warning {
            margin-top: 40px;
            font-size: 12px;
            color: #222;
            letter-spacing: 0.3em;
        }
        
        /* Overlays */
        .overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .vignette {
            background: radial-gradient(ellipse at center, transparent 0%, transparent 50%, rgba(0,0,0,0.8) 100%);
        }
        
        .film-grain {
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
            animation: grain 0.3s steps(6) infinite;
        }
        
        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            20% { transform: translate(-2%, -2%); }
            40% { transform: translate(2%, 2%); }
            60% { transform: translate(-1%, 1%); }
            80% { transform: translate(1%, -1%); }
        }
        
        .flash-overlay {
            background: #fff;
            opacity: 0;
            transition: opacity 0.05s;
            z-index: 200;
        }
        
        .blood-overlay {
            background: radial-gradient(ellipse at center, #330000 0%, #1a0000 50%, #000 100%);
            opacity: 0;
            z-index: 150;
        }
        
        .blackout {
            background: #000;
            opacity: 0;
            z-index: 300;
        }
        
        /* Title */
        .title-container {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
        }
        
        .title-container.visible {
            opacity: 1;
        }
        
        .title {
            font-family: 'Arial Black', sans-serif;
            font-size: clamp(80px, 22vw, 350px);
            font-weight: 900;
            letter-spacing: 0.05em;
            display: flex;
        }
        
        .letter {
            display: inline-block;
            opacity: 0;
            color: #ff0000;
            text-shadow: 
                0 0 20px rgba(255, 0, 0, 0.8),
                0 0 40px rgba(255, 0, 0, 0.6),
                0 0 80px rgba(255, 0, 0, 0.4),
                0 0 120px rgba(200, 0, 0, 0.3);
            transform: translateY(-100px) scale(1.5);
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
        }
        
        .letter.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .studio {
            margin-top: 60px;
            font-size: clamp(12px, 2vw, 18px);
            color: #444;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 2s ease-out;
        }
        
        .studio.visible {
            opacity: 1;
        }
        
        .studio span {
            color: #880000;
        }
        
        .skip {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 12px;
            color: #333;
            letter-spacing: 0.2em;
            z-index: 400;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .skip.visible {
            opacity: 0.4;
        }
    </style>
</head>
<body>
    <!-- Audio -->
    <audio id="bgMusic" preload="auto"><source src="dark-80s-sci-fi-atmosphere-425528.mp3" type="audio/mpeg"></audio>
    <audio id="doorSound" preload="auto"><source src="metallic-door-shut-98740.mp3" type="audio/mpeg"></audio>
    <audio id="screamSound" preload="auto"><source src="falling-man-scream-450793.mp3" type="audio/mpeg"></audio>
    <audio id="roarSound" preload="auto"><source src="monster-roar-02-102957.mp3" type="audio/mpeg"></audio>
    
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <div class="start-text">Click to Begin</div>
        <div class="start-warning">âš  HEADPHONES RECOMMENDED</div>
    </div>
    
    <!-- Three.js Canvas -->
    <div id="canvas-container"></div>
    
    <!-- Overlays -->
    <div class="overlay vignette"></div>
    <div class="overlay film-grain"></div>
    <div class="overlay flash-overlay" id="flashOverlay"></div>
    <div class="overlay blood-overlay" id="bloodOverlay"></div>
    <div class="overlay blackout" id="blackout"></div>
    
    <!-- Title -->
    <div class="title-container" id="titleContainer">
        <div class="title">
            <span class="letter">P</span>
            <span class="letter">R</span>
            <span class="letter">E</span>
            <span class="letter">S</span>
            <span class="letter">S</span>
            <span class="letter">.</span>
        </div>
        <div class="studio" id="studio">An <span>Invariant Games</span> Production</div>
    </div>
    
    <div class="skip" id="skip">ESC TO SKIP</div>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== SETUP ====================
        const container = document.getElementById('canvas-container');
        const flashOverlay = document.getElementById('flashOverlay');
        const bloodOverlay = document.getElementById('bloodOverlay');
        const blackout = document.getElementById('blackout');
        const titleContainer = document.getElementById('titleContainer');
        const letters = document.querySelectorAll('.letter');
        const studio = document.getElementById('studio');
        const skip = document.getElementById('skip');
        
        // Audio
        const bgMusic = document.getElementById('bgMusic');
        const doorSound = document.getElementById('doorSound');
        const screamSound = document.getElementById('screamSound');
        const roarSound = document.getElementById('roarSound');
        
        bgMusic.volume = 0.7;
        doorSound.volume = 0.9;
        screamSound.volume = 0.7;
        roarSound.volume = 1.0;
        
        // Three.js Scene
        let scene, camera, renderer;
        let currentScene = null;
        let clock = new THREE.Clock();
        let introStarted = false;
        
        // Camera shake
        let shakeIntensity = 0;
        let shakeDuration = 0;
        
        // Head bob
        let headBobEnabled = false;
        let headBobIntensity = 1;
        let headBobSpeed = 1;
        let headBobTime = 0;
        
        // Initialize
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.physicallyCorrectLights = true;
            container.appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ==================== SCENE BUILDERS ====================

        // STREET SCENE (Opening kidnapping)
        function buildStreetScene() {
            clearScene();

            scene.fog = new THREE.FogExp2(0x050515, 0.015);
            scene.background = new THREE.Color(0x020208);

            // Enhanced moonlight with better shadows
            const moonlight = new THREE.DirectionalLight(0x7799bb, 0.6);
            moonlight.position.set(-15, 25, -15);
            moonlight.castShadow = true;
            moonlight.shadow.mapSize.width = 4096;
            moonlight.shadow.mapSize.height = 4096;
            moonlight.shadow.camera.near = 0.5;
            moonlight.shadow.camera.far = 150;
            moonlight.shadow.camera.left = -60;
            moonlight.shadow.camera.right = 60;
            moonlight.shadow.camera.top = 60;
            moonlight.shadow.camera.bottom = -60;
            moonlight.shadow.bias = -0.0001;
            moonlight.shadow.normalBias = 0.02;
            scene.add(moonlight);

            // Ambient night light with blue tint
            const ambient = new THREE.AmbientLight(0x1a1a3a, 0.25);
            scene.add(ambient);

            // Hemisphere light for more realistic sky/ground lighting
            const hemiLight = new THREE.HemisphereLight(0x2244aa, 0x0a0a0a, 0.3);
            scene.add(hemiLight);

            // Road with wet asphalt appearance
            const roadGeo = new THREE.PlaneGeometry(12, 100);
            const roadMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.4,
                metalness: 0.6,
                envMapIntensity: 0.5
            });
            const road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0;
            road.position.x = -3;
            road.receiveShadow = true;
            scene.add(road);

            // Road lines
            const lineGeo = new THREE.PlaneGeometry(0.2, 100);
            const lineMat = new THREE.MeshBasicMaterial({
                color: 0x888844,
                transparent: true,
                opacity: 0.6
            });
            const centerLine = new THREE.Mesh(lineGeo, lineMat);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.y = 0.01;
            centerLine.position.x = -3;
            scene.add(centerLine);

            // Sidewalk (right side where player walks)
            const sidewalkGeo = new THREE.PlaneGeometry(3, 100);
            const sidewalkMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.95,
                metalness: 0
            });
            const sidewalk = new THREE.Mesh(sidewalkGeo, sidewalkMat);
            sidewalk.rotation.x = -Math.PI / 2;
            sidewalk.position.y = 0.02;
            sidewalk.position.x = 2.5;
            sidewalk.receiveShadow = true;
            scene.add(sidewalk);

            // Sidewalk (left side)
            const sidewalkLeft = new THREE.Mesh(sidewalkGeo, sidewalkMat);
            sidewalkLeft.rotation.x = -Math.PI / 2;
            sidewalkLeft.position.y = 0.02;
            sidewalkLeft.position.x = -8.5;
            sidewalkLeft.receiveShadow = true;
            scene.add(sidewalkLeft);

            // Buildings on right side
            const buildingMat = new THREE.MeshStandardMaterial({
                color: 0x1a1520,
                roughness: 0.8,
                metalness: 0.1
            });

            const windowMat = new THREE.MeshStandardMaterial({
                color: 0x3a3020,
                emissive: 0x4a4020,
                emissiveIntensity: 0.3,
                roughness: 0.2,
                metalness: 0.3
            });

            // Create buildings along the street
            for (let z = -40; z < 20; z += 12) {
                // Right side building
                const height = 8 + Math.random() * 6;
                const buildingGeo = new THREE.BoxGeometry(4, height, 10);
                const building = new THREE.Mesh(buildingGeo, buildingMat);
                building.position.set(6, height / 2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);

                // Windows for right building
                for (let floor = 0; floor < Math.floor(height / 3); floor++) {
                    for (let w = 0; w < 3; w++) {
                        if (Math.random() > 0.3) {
                            const windowGeo = new THREE.PlaneGeometry(0.8, 1.2);
                            const window = new THREE.Mesh(windowGeo, windowMat);
                            window.position.set(4.01, 2 + floor * 3, z - 3 + w * 3);
                            window.rotation.y = -Math.PI / 2;
                            scene.add(window);

                            // Some window lights
                            if (Math.random() > 0.7) {
                                const windowLight = new THREE.PointLight(0xffaa44, 0.3, 5);
                                windowLight.position.set(4.5, 2 + floor * 3, z - 3 + w * 3);
                                scene.add(windowLight);
                            }
                        }
                    }
                }

                // Left side building
                const leftHeight = 7 + Math.random() * 5;
                const leftBuildingGeo = new THREE.BoxGeometry(4, leftHeight, 10);
                const leftBuilding = new THREE.Mesh(leftBuildingGeo, buildingMat);
                leftBuilding.position.set(-12, leftHeight / 2, z + 6);
                leftBuilding.castShadow = true;
                leftBuilding.receiveShadow = true;
                scene.add(leftBuilding);

                // Windows for left building
                for (let floor = 0; floor < Math.floor(leftHeight / 3); floor++) {
                    for (let w = 0; w < 3; w++) {
                        if (Math.random() > 0.3) {
                            const windowGeo = new THREE.PlaneGeometry(0.8, 1.2);
                            const window = new THREE.Mesh(windowGeo, windowMat);
                            window.position.set(-10.01, 2 + floor * 3, z + 3 + w * 3);
                            window.rotation.y = Math.PI / 2;
                            scene.add(window);

                            if (Math.random() > 0.7) {
                                const windowLight = new THREE.PointLight(0xffaa44, 0.3, 5);
                                windowLight.position.set(-10.5, 2 + floor * 3, z + 3 + w * 3);
                                scene.add(windowLight);
                            }
                        }
                    }
                }
            }

            // Street lamps with enhanced lighting
            const lampPostMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.3,
                metalness: 0.8
            });

            for (let z = -30; z < 10; z += 15) {
                // Right sidewalk lamp
                const lampPost = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 5, 16), lampPostMat);
                lampPost.position.set(3.5, 2.5, z);
                lampPost.castShadow = true;
                scene.add(lampPost);

                // Lamp head
                const lampHead = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.15, 0.3, 16), lampPostMat);
                lampHead.position.set(3.5, 5.2, z);
                scene.add(lampHead);

                // Main lamp light with shadows
                const lampLight = new THREE.PointLight(0xffbb77, 3, 25, 2);
                lampLight.position.set(3.5, 5, z);
                lampLight.castShadow = true;
                lampLight.shadow.mapSize.width = 1024;
                lampLight.shadow.mapSize.height = 1024;
                lampLight.shadow.bias = -0.001;
                scene.add(lampLight);

                // Volumetric light cone effect
                const coneGeo = new THREE.ConeGeometry(4, 8, 8, 1, true);
                const coneMat = new THREE.MeshBasicMaterial({
                    color: 0xffaa55,
                    transparent: true,
                    opacity: 0.08,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const lightCone = new THREE.Mesh(coneGeo, coneMat);
                lightCone.position.set(3.5, 5, z);
                lightCone.rotation.x = Math.PI;
                scene.add(lightCone);

                // Lamp glow with better appearance
                const glowGeo = new THREE.SphereGeometry(0.22, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xffdd99,
                    transparent: true,
                    opacity: 0.95
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.set(3.5, 5, z);
                scene.add(glow);

                // Ground light pool
                const poolGeo = new THREE.CircleGeometry(3.5, 32);
                const poolMat = new THREE.MeshBasicMaterial({
                    color: 0xffaa55,
                    transparent: true,
                    opacity: 0.15,
                    depthWrite: false
                });
                const lightPool = new THREE.Mesh(poolGeo, poolMat);
                lightPool.rotation.x = -Math.PI / 2;
                lightPool.position.set(3.5, 0.03, z);
                scene.add(lightPool);
            }

            // Add environmental details
            // Trash cans
            const trashCanGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.8, 12);
            const trashCanMat = new THREE.MeshStandardMaterial({
                color: 0x2a4a2a,
                roughness: 0.8,
                metalness: 0.3
            });

            const trashCan1 = new THREE.Mesh(trashCanGeo, trashCanMat);
            trashCan1.position.set(3.8, 0.4, -8);
            trashCan1.castShadow = true;
            scene.add(trashCan1);

            const trashCan2 = new THREE.Mesh(trashCanGeo, trashCanMat);
            trashCan2.position.set(3.7, 0.4, -22);
            trashCan2.castShadow = true;
            scene.add(trashCan2);

            // Fire hydrant
            const hydrantBodyGeo = new THREE.CylinderGeometry(0.2, 0.25, 0.6, 8);
            const hydrantMat = new THREE.MeshStandardMaterial({
                color: 0x8a1a1a,
                roughness: 0.6,
                metalness: 0.4
            });
            const hydrant = new THREE.Mesh(hydrantBodyGeo, hydrantMat);
            hydrant.position.set(3.9, 0.3, 3);
            hydrant.castShadow = true;
            scene.add(hydrant);

            // Hydrant cap
            const capGeo = new THREE.CylinderGeometry(0.25, 0.22, 0.15, 8);
            const cap = new THREE.Mesh(capGeo, hydrantMat);
            cap.position.set(3.9, 0.65, 3);
            scene.add(cap);

            // Parked cars
            for (let i = 0; i < 3; i++) {
                const parkedCar = createParkedCar();
                parkedCar.position.set(-5.5, 0, -15 - i * 8);
                parkedCar.rotation.y = Math.PI;
                scene.add(parkedCar);
            }

            // Steam from manhole (atmospheric effect)
            const steamGeo = new THREE.ConeGeometry(0.8, 3, 8, 1, true);
            const steamMat = new THREE.MeshBasicMaterial({
                color: 0xccddee,
                transparent: true,
                opacity: 0.12,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const steam = new THREE.Mesh(steamGeo, steamMat);
            steam.position.set(-1, 1.5, -12);
            scene.add(steam);
            scene.userData.steam = steam;

            // Create the van (initially behind player)
            const van = createVan();
            van.position.set(-5, 0, 25);
            van.rotation.y = Math.PI;
            scene.add(van);
            scene.userData.van = van;

            // Create kidnappers (initially hidden in van)
            const kidnapper1 = createKidnapper();
            kidnapper1.position.set(-4, 0, 0);
            kidnapper1.visible = false;
            scene.add(kidnapper1);
            scene.userData.kidnapper1 = kidnapper1;

            const kidnapper2 = createKidnapper();
            kidnapper2.position.set(-6, 0, 0);
            kidnapper2.visible = false;
            scene.add(kidnapper2);
            scene.userData.kidnapper2 = kidnapper2;

            camera.position.set(2.5, 1.7, 0);
            camera.rotation.set(0, 0, 0);
            camera.lookAt(2.5, 1.7, -10);
        }

        // Create parked car model
        function createParkedCar() {
            const carGroup = new THREE.Group();

            const carMat = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.5 ? 0x2a2a3a : 0x3a2a2a,
                roughness: 0.4,
                metalness: 0.7
            });

            // Car body
            const bodyGeo = new THREE.BoxGeometry(2, 1.2, 4);
            const body = new THREE.Mesh(bodyGeo, carMat);
            body.position.y = 0.8;
            body.castShadow = true;
            carGroup.add(body);

            // Car roof
            const roofGeo = new THREE.BoxGeometry(1.8, 0.8, 2.2);
            const roof = new THREE.Mesh(roofGeo, carMat);
            roof.position.set(0, 1.6, -0.3);
            roof.castShadow = true;
            carGroup.add(roof);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.25, 12);
            const wheelMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.9
            });

            const wheelPositions = [
                { x: -0.9, z: 1.3 },
                { x: 0.9, z: 1.3 },
                { x: -0.9, z: -1.3 },
                { x: 0.9, z: -1.3 }
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, 0.3, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);
            });

            return carGroup;
        }

        // Create van model (enhanced)
        function createVan() {
            const vanGroup = new THREE.Group();

            // Main body with better material
            const bodyGeo = new THREE.BoxGeometry(2.5, 2, 5);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.5,
                metalness: 0.6
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.5;
            body.castShadow = true;
            body.receiveShadow = true;
            vanGroup.add(body);

            // Cabin
            const cabinGeo = new THREE.BoxGeometry(2.5, 1.5, 2.2);
            const cabin = new THREE.Mesh(cabinGeo, bodyMat);
            cabin.position.set(0, 2.75, 1.6);
            cabin.castShadow = true;
            vanGroup.add(cabin);

            // Windshield
            const windshieldGeo = new THREE.BoxGeometry(2.3, 1.2, 0.1);
            const windshieldMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a1a,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.8
            });
            const windshield = new THREE.Mesh(windshieldGeo, windshieldMat);
            windshield.position.set(0, 2.8, 2.65);
            windshield.rotation.x = -0.1;
            vanGroup.add(windshield);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wheelMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.8
            });

            const wheelPositions = [
                { x: -1.1, z: 1.8 },
                { x: 1.1, z: 1.8 },
                { x: -1.1, z: -1.8 },
                { x: 1.1, z: -1.8 }
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, 0.4, pos.z);
                wheel.castShadow = true;
                vanGroup.add(wheel);
            });

            // Headlights
            const headlightGeo = new THREE.BoxGeometry(0.3, 0.2, 0.1);
            const headlightMat = new THREE.MeshStandardMaterial({
                color: 0xffeeaa,
                emissive: 0xffeeaa,
                emissiveIntensity: 0.5
            });

            const leftHeadlight = new THREE.Mesh(headlightGeo, headlightMat);
            leftHeadlight.position.set(-0.8, 1.2, 2.55);
            vanGroup.add(leftHeadlight);

            const rightHeadlight = new THREE.Mesh(headlightGeo, headlightMat);
            rightHeadlight.position.set(0.8, 1.2, 2.55);
            vanGroup.add(rightHeadlight);

            // Enhanced headlight beams
            const leftBeam = new THREE.SpotLight(0xffeedd, 4, 40, Math.PI / 5, 0.5, 2);
            leftBeam.position.set(-0.8, 1.2, 2.6);
            leftBeam.target.position.set(-0.8, 0, 30);
            leftBeam.castShadow = true;
            leftBeam.shadow.mapSize.width = 512;
            leftBeam.shadow.mapSize.height = 512;
            vanGroup.add(leftBeam);
            vanGroup.add(leftBeam.target);

            const rightBeam = new THREE.SpotLight(0xffeedd, 4, 40, Math.PI / 5, 0.5, 2);
            rightBeam.position.set(0.8, 1.2, 2.6);
            rightBeam.target.position.set(0.8, 0, 30);
            rightBeam.castShadow = true;
            rightBeam.shadow.mapSize.width = 512;
            rightBeam.shadow.mapSize.height = 512;
            vanGroup.add(rightBeam);
            vanGroup.add(rightBeam.target);

            // Brake lights (rear)
            const brakeLeftGeo = new THREE.BoxGeometry(0.25, 0.15, 0.08);
            const brakeMat = new THREE.MeshStandardMaterial({
                color: 0x440000,
                emissive: 0x440000,
                emissiveIntensity: 0.3
            });

            const brakeLeft = new THREE.Mesh(brakeLeftGeo, brakeMat);
            brakeLeft.position.set(-0.9, 1.3, -2.52);
            vanGroup.add(brakeLeft);

            const brakeRight = new THREE.Mesh(brakeLeftGeo, brakeMat);
            brakeRight.position.set(0.9, 1.3, -2.52);
            vanGroup.add(brakeRight);

            vanGroup.userData.brakeLeft = brakeLeft;
            vanGroup.userData.brakeRight = brakeRight;

            // Side door (sliding door on right side)
            const doorGeo = new THREE.BoxGeometry(0.1, 1.6, 1.8);
            const doorMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.6,
                metalness: 0.3
            });
            const slidingDoor = new THREE.Mesh(doorGeo, doorMat);
            slidingDoor.position.set(1.3, 1.5, -0.5);
            slidingDoor.castShadow = true;
            vanGroup.add(slidingDoor);
            vanGroup.userData.door = slidingDoor;

            return vanGroup;
        }

        // Create kidnapper model
        function createKidnapper() {
            const kidnapper = new THREE.Group();

            // Dark clothing material
            const clothingMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.9,
                metalness: 0
            });

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.4, 12);
            const body = new THREE.Mesh(bodyGeo, clothingMat);
            body.position.y = 1.2;
            body.castShadow = true;
            kidnapper.add(body);

            // Head with balaclava
            const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.85
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.1;
            head.castShadow = true;
            kidnapper.add(head);

            // Eyes (barely visible)
            const eyeMat = new THREE.MeshBasicMaterial({
                color: 0x1a1510,
                transparent: true,
                opacity: 0.6
            });

            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
            leftEye.position.set(-0.08, 2.12, -0.22);
            kidnapper.add(leftEye);

            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
            rightEye.position.set(0.08, 2.12, -0.22);
            kidnapper.add(rightEye);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.12, 0.1, 1, 8);

            const leftArm = new THREE.Mesh(armGeo, clothingMat);
            leftArm.position.set(-0.5, 1.2, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            kidnapper.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, clothingMat);
            rightArm.position.set(0.5, 1.2, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            kidnapper.add(rightArm);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.15, 0.13, 1, 8);

            const leftLeg = new THREE.Mesh(legGeo, clothingMat);
            leftLeg.position.set(-0.2, 0.5, 0);
            leftLeg.castShadow = true;
            kidnapper.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, clothingMat);
            rightLeg.position.set(0.2, 0.5, 0);
            rightLeg.castShadow = true;
            kidnapper.add(rightLeg);

            return kidnapper;
        }

        // HALLWAY SCENE
        function buildHallwayScene() {
            clearScene();
            
            scene.fog = new THREE.Fog(0x0a0505, 1, 25);
            scene.background = new THREE.Color(0x050202);
            
            // Ambient light
            const ambient = new THREE.AmbientLight(0x1a0a0a, 0.3);
            scene.add(ambient);
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(6, 50);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x1a0808,
                roughness: 0.9,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Floor tiles pattern
            const tileGeo = new THREE.PlaneGeometry(5.8, 49.8);
            const tileMat = new THREE.MeshStandardMaterial({
                color: 0x150606,
                roughness: 0.85,
                metalness: 0.05
            });
            const tiles = new THREE.Mesh(tileGeo, tileMat);
            tiles.rotation.x = -Math.PI / 2;
            tiles.position.y = 0.001;
            scene.add(tiles);
            
            // Ceiling
            const ceilingGeo = new THREE.PlaneGeometry(6, 50);
            const ceilingMat = new THREE.MeshStandardMaterial({
                color: 0x0a0404,
                roughness: 0.95,
                metalness: 0
            });
            const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 3.5;
            scene.add(ceiling);
            
            // Walls
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0x120606,
                roughness: 0.9,
                metalness: 0.05
            });
            
            const wallGeo = new THREE.PlaneGeometry(50, 3.5);
            
            const leftWall = new THREE.Mesh(wallGeo, wallMat);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-3, 1.75, 0);
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(wallGeo, wallMat);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(3, 1.75, 0);
            scene.add(rightWall);
            
            // Wall panels
            const panelGeo = new THREE.BoxGeometry(0.1, 2, 1.2);
            const panelMat = new THREE.MeshStandardMaterial({
                color: 0x0d0404,
                roughness: 0.85
            });
            
            for (let z = -20; z < 0; z += 4) {
                const leftPanel = new THREE.Mesh(panelGeo, panelMat);
                leftPanel.position.set(-2.9, 1.5, z);
                scene.add(leftPanel);
                
                const rightPanel = new THREE.Mesh(panelGeo, panelMat);
                rightPanel.position.set(2.9, 1.5, z);
                scene.add(rightPanel);
            }
            
            // Ceiling lights
            for (let z = -20; z < 0; z += 5) {
                const light = new THREE.PointLight(0xff4420, 0.8, 8);
                light.position.set(0, 3.3, z);
                light.castShadow = true;
                scene.add(light);
                
                // Light fixture
                const fixtureGeo = new THREE.BoxGeometry(0.8, 0.1, 0.3);
                const fixtureMat = new THREE.MeshStandardMaterial({
                    color: 0x331100,
                    emissive: 0x441100,
                    emissiveIntensity: 0.5
                });
                const fixture = new THREE.Mesh(fixtureGeo, fixtureMat);
                fixture.position.set(0, 3.45, z);
                scene.add(fixture);
            }
            
            // THE DOOR
            const doorGroup = new THREE.Group();
            doorGroup.position.set(0, 0, -22);
            
            // Door frame
            const frameMat = new THREE.MeshStandardMaterial({
                color: 0x1a0808,
                roughness: 0.8
            });
            
            const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.8, 0.2), frameMat);
            frameLeft.position.set(-0.9, 1.4, 0);
            doorGroup.add(frameLeft);
            
            const frameRight = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.8, 0.2), frameMat);
            frameRight.position.set(0.9, 1.4, 0);
            doorGroup.add(frameRight);
            
            const frameTop = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 0.2), frameMat);
            frameTop.position.set(0, 2.85, 0);
            doorGroup.add(frameTop);
            
            // Door itself
            const doorMat = new THREE.MeshStandardMaterial({
                color: 0x2a1210,
                roughness: 0.7,
                metalness: 0.1
            });
            const door = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.6, 0.08), doorMat);
            door.position.set(0, 1.35, 0);
            door.castShadow = true;
            doorGroup.add(door);
            
            // Door handle
            const handleMat = new THREE.MeshStandardMaterial({
                color: 0x4a3020,
                roughness: 0.5,
                metalness: 0.6
            });
            const handle = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 16), handleMat);
            handle.position.set(0.6, 1.3, 0.06);
            doorGroup.add(handle);
            
            // Light under door
            const doorLight = new THREE.PointLight(0xff5520, 2, 5);
            doorLight.position.set(0, 0.1, 0.5);
            doorGroup.add(doorLight);
            
            // Light glow plane
            const glowGeo = new THREE.PlaneGeometry(1.4, 0.08);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xff6030,
                transparent: true,
                opacity: 0.9
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.rotation.x = -Math.PI / 2;
            glow.position.set(0, 0.01, 0.15);
            doorGroup.add(glow);
            
            scene.add(doorGroup);
            scene.userData.door = doorGroup;
            
            // CHASER (shadow entity behind player)
            const chaserGroup = new THREE.Group();
            chaserGroup.position.set(0, 0, 8);
            
            // Body
            const chaserBodyGeo = new THREE.CylinderGeometry(0.5, 0.7, 2.5, 8);
            const chaserBodyMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.95
            });
            const chaserBody = new THREE.Mesh(chaserBodyGeo, chaserBodyMat);
            chaserBody.position.y = 1.25;
            chaserGroup.add(chaserBody);
            
            // Head
            const chaserHeadGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const chaserHead = new THREE.Mesh(chaserHeadGeo, chaserBodyMat);
            chaserHead.position.y = 2.7;
            chaserGroup.add(chaserHead);
            
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), eyeMat);
            leftEye.position.set(-0.15, 2.75, -0.35);
            chaserGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), eyeMat);
            rightEye.position.set(0.15, 2.75, -0.35);
            chaserGroup.add(rightEye);
            
            // Eye lights
            const eyeLight = new THREE.PointLight(0xff0000, 0.5, 3);
            eyeLight.position.set(0, 2.75, -0.3);
            chaserGroup.add(eyeLight);
            
            scene.add(chaserGroup);
            scene.userData.chaser = chaserGroup;
            
            camera.position.set(0, 1.7, 0);
            camera.lookAt(0, 1.7, -22);
        }
        
        // FOREST SCENE
        function buildForestScene() {
            clearScene();
            
            scene.fog = new THREE.FogExp2(0x020504, 0.08);
            scene.background = new THREE.Color(0x010302);
            
            // Dim moonlight
            const moonlight = new THREE.DirectionalLight(0x334455, 0.15);
            moonlight.position.set(5, 10, -5);
            scene.add(moonlight);
            
            // Ambient
            const ambient = new THREE.AmbientLight(0x0a1510, 0.2);
            scene.add(ambient);
            
            // Ground
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x0a1508,
                roughness: 1,
                metalness: 0
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Trees
            const treeMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a08,
                roughness: 0.9
            });
            
            const foliageMat = new THREE.MeshStandardMaterial({
                color: 0x0a1a0a,
                roughness: 0.95
            });
            
            const treePositions = [
                // Close trees (around player)
                { x: -4, z: -3, scale: 1.2 },
                { x: 5, z: -2, scale: 1.3 },
                { x: -3, z: -8, scale: 1.1 },
                { x: 4, z: -6, scale: 1.0 },
                { x: -6, z: -5, scale: 1.4 },
                { x: 7, z: -4, scale: 1.2 },
                // Medium distance
                { x: -8, z: -12, scale: 1.0 },
                { x: 9, z: -10, scale: 1.1 },
                { x: -2, z: -15, scale: 0.9 },
                { x: 3, z: -14, scale: 1.0 },
                { x: -10, z: -8, scale: 1.3 },
                { x: 11, z: -7, scale: 1.2 },
                // Far trees
                { x: -5, z: -22, scale: 0.8 },
                { x: 6, z: -20, scale: 0.85 },
                { x: -12, z: -18, scale: 0.9 },
                { x: 13, z: -16, scale: 0.95 },
                { x: 0, z: -25, scale: 0.7 },
                // Behind player
                { x: -4, z: 5, scale: 1.1 },
                { x: 5, z: 6, scale: 1.2 },
                { x: -7, z: 8, scale: 1.0 },
                { x: 8, z: 7, scale: 1.15 },
            ];
            
            treePositions.forEach(pos => {
                const tree = new THREE.Group();
                
                // Trunk
                const trunkHeight = 4 + Math.random() * 3;
                const trunkGeo = new THREE.CylinderGeometry(0.15 * pos.scale, 0.25 * pos.scale, trunkHeight * pos.scale, 8);
                const trunk = new THREE.Mesh(trunkGeo, treeMat);
                trunk.position.y = (trunkHeight * pos.scale) / 2;
                trunk.castShadow = true;
                tree.add(trunk);
                
                // Foliage layers
                for (let i = 0; i < 3; i++) {
                    const size = (1.8 - i * 0.4) * pos.scale;
                    const foliageGeo = new THREE.ConeGeometry(size, size * 1.5, 8);
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.y = (trunkHeight * pos.scale) + i * 1.2 * pos.scale;
                    foliage.castShadow = true;
                    tree.add(foliage);
                }
                
                tree.position.set(pos.x, 0, pos.z);
                scene.add(tree);
            });
            
            // Watching eyes in darkness
            const eyePositions = [
                { x: -6, y: 1.5, z: -10 },
                { x: 8, y: 1.8, z: -8 },
                { x: -10, y: 1.3, z: -15 },
                { x: 12, y: 1.6, z: -12 },
                { x: -3, y: 2.0, z: -20 },
            ];
            
            eyePositions.forEach(pos => {
                const eyeGroup = new THREE.Group();
                
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff2200 });
                
                const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
                leftEye.position.x = -0.1;
                eyeGroup.add(leftEye);
                
                const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
                rightEye.position.x = 0.1;
                eyeGroup.add(rightEye);
                
                const eyeLight = new THREE.PointLight(0xff2200, 0.3, 2);
                eyeGroup.add(eyeLight);
                
                eyeGroup.position.set(pos.x, pos.y, pos.z);
                eyeGroup.lookAt(0, 1.7, 0);
                scene.add(eyeGroup);
            });
            
            // Entity (far behind, watching)
            const entityGroup = createEntity();
            entityGroup.position.set(0, 0, 15);
            entityGroup.scale.set(0.8, 0.8, 0.8);
            scene.add(entityGroup);
            scene.userData.entity = entityGroup;
            
            camera.position.set(0, 1.7, 0);
            camera.lookAt(0, 1.7, -15);
        }
        
        // Create entity model
        function createEntity() {
            const entity = new THREE.Group();
            
            const bodyMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.98
            });
            
            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.6, 0.9, 3, 12);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.5;
            entity.add(body);
            
            // Head
            const headGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.y = 3.2;
            head.scale.set(1, 1.2, 1);
            entity.add(head);
            
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), eyeMat);
            leftEye.position.set(-0.2, 3.3, -0.4);
            entity.add(leftEye);
            
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), eyeMat);
            rightEye.position.set(0.2, 3.3, -0.4);
            entity.add(rightEye);
            
            // Eye glow
            const eyeGlow = new THREE.PointLight(0xff0000, 1, 5);
            eyeGlow.position.set(0, 3.3, -0.3);
            entity.add(eyeGlow);
            
            // Mouth
            const mouthGeo = new THREE.BoxGeometry(0.4, 0.25, 0.15);
            const mouthMat = new THREE.MeshBasicMaterial({ color: 0x100000 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 3.0, -0.45);
            entity.add(mouth);
            
            // Teeth
            const toothMat = new THREE.MeshBasicMaterial({ color: 0xccccaa });
            for (let i = -3; i <= 3; i++) {
                const tooth = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.12, 4), toothMat);
                tooth.position.set(i * 0.05, 2.92, -0.45);
                tooth.rotation.x = Math.PI;
                entity.add(tooth);
            }
            
            // Arms/tendrils
            const armMat = new THREE.MeshBasicMaterial({
                color: 0x050505,
                transparent: true,
                opacity: 0.9
            });
            
            for (let i = 0; i < 4; i++) {
                const armGeo = new THREE.CylinderGeometry(0.08, 0.15, 1.5, 8);
                const arm = new THREE.Mesh(armGeo, armMat);
                const angle = (i - 1.5) * 0.4;
                const side = i < 2 ? -1 : 1;
                arm.position.set(side * 0.7, 1.8, 0);
                arm.rotation.z = side * 0.5;
                entity.add(arm);
            }
            
            return entity;
        }
        
        // LOOKBACK SCENE (entity close up)
        function buildLookbackScene() {
            clearScene();
            
            scene.fog = new THREE.Fog(0x010201, 1, 15);
            scene.background = new THREE.Color(0x010101);
            
            const ambient = new THREE.AmbientLight(0x0a0505, 0.1);
            scene.add(ambient);
            
            // Entity right in front
            const entity = createEntity();
            entity.position.set(0, 0, -3);
            entity.scale.set(1.5, 1.5, 1.5);
            scene.add(entity);
            scene.userData.entity = entity;
            
            // Dramatic red backlight
            const backlight = new THREE.PointLight(0xff0000, 0.5, 10);
            backlight.position.set(0, 3, -5);
            scene.add(backlight);
            
            camera.position.set(0, 1.7, 0);
            camera.lookAt(0, 2.5, -3);
        }
        
        // GROUND VIEW (after falling)
        function buildGroundScene() {
            clearScene();
            
            scene.fog = new THREE.FogExp2(0x020302, 0.1);
            scene.background = new THREE.Color(0x010201);
            
            const ambient = new THREE.AmbientLight(0x0a1008, 0.15);
            scene.add(ambient);
            
            // Ground (close up)
            const groundGeo = new THREE.PlaneGeometry(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x0a1208,
                roughness: 1
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            
            // Debris
            const debrisMat = new THREE.MeshStandardMaterial({
                color: 0x151a12,
                roughness: 0.95
            });
            
            for (let i = 0; i < 15; i++) {
                const debris = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1 + Math.random() * 0.2, 8, 8),
                    debrisMat
                );
                debris.position.set(
                    (Math.random() - 0.5) * 4,
                    0.05,
                    (Math.random() - 0.5) * 4
                );
                debris.scale.y = 0.3;
                scene.add(debris);
            }
            
            // Entity looming above
            const entity = createEntity();
            entity.position.set(0, 0, -2);
            entity.scale.set(2, 2, 2);
            scene.add(entity);
            scene.userData.entity = entity;
            
            // Looking up from ground
            camera.position.set(0, 0.3, 0);
            camera.lookAt(0, 3, -2);
        }
        
        // TITLE SCENE
        function buildTitleScene() {
            clearScene();
            
            scene.background = new THREE.Color(0x000000);
            scene.fog = null;
            
            // Subtle red ambient
            const ambient = new THREE.AmbientLight(0x1a0000, 0.2);
            scene.add(ambient);
            
            // Red point light
            const redLight = new THREE.PointLight(0xff0000, 0.3, 20);
            redLight.position.set(0, 2, 5);
            scene.add(redLight);
            
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
        }
        
        function clearScene() {
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            scene.userData = {};
        }
        
        // ==================== ANIMATION ====================
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Head bob
            if (headBobEnabled) {
                headBobTime += delta * headBobSpeed * 10;
                const bobY = Math.sin(headBobTime * 2) * 0.08 * headBobIntensity;
                const bobX = Math.sin(headBobTime) * 0.03 * headBobIntensity;
                const tiltZ = Math.sin(headBobTime) * 0.01 * headBobIntensity;
                
                camera.position.y += bobY * delta * 10;
                camera.position.x += bobX * delta * 10;
                camera.rotation.z = tiltZ;
            }
            
            // Camera shake
            if (shakeDuration > 0) {
                shakeDuration -= delta;
                const intensity = shakeIntensity * (shakeDuration / 0.5);
                camera.position.x += (Math.random() - 0.5) * intensity * 0.3;
                camera.position.y += (Math.random() - 0.5) * intensity * 0.2;
                camera.rotation.z += (Math.random() - 0.5) * intensity * 0.02;
            }
            
            renderer.render(scene, camera);
        }
        
        // ==================== EFFECTS ====================
        
        function shake(intensity, duration) {
            shakeIntensity = intensity;
            shakeDuration = duration;
        }
        
        function flash(duration = 100) {
            flashOverlay.style.opacity = '1';
            setTimeout(() => {
                flashOverlay.style.transition = `opacity ${duration}ms ease-out`;
                flashOverlay.style.opacity = '0';
                setTimeout(() => flashOverlay.style.transition = '', duration);
            }, 30);
        }
        
        function triggerBlackout(duration) {
            blackout.style.opacity = '1';
            setTimeout(() => {
                blackout.style.transition = `opacity ${duration}ms`;
                blackout.style.opacity = '0';
            }, duration / 2);
        }
        
        // ==================== SCENES ====================

        async function runIntro() {
            skip.classList.add('visible');

            // SCENE 0: Kidnapping (0-9s)
            await runKidnappingScene();

            // SCENE 1: Hallway chase (0-5s)
            await runHallwayChase();
            
            // SCENE 2: Forest run (5-10s)
            await runForestRun();
            
            // SCENE 3: Look back (10-12.5s)
            await runLookback();
            
            // SCENE 4: Fall (12.5-14s)
            await runFall();
            
            // SCENE 5: Entity attack (14-17s)
            await runEntityAttack();
            
            // SCENE 6: Blood/Death (17-21s)
            await runBloodScene();
            
            // SCENE 7: Title (21-32s)
            await runTitleReveal();
        }

        // Smooth easing functions
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function easeOutQuart(t) {
            return 1 - Math.pow(1 - t, 4);
        }

        function easeInQuart(t) {
            return t * t * t * t;
        }

        function easeInOutQuart(t) {
            return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
        }

        function runKidnappingScene() {
            return new Promise(resolve => {
                buildStreetScene();

                const van = scene.userData.van;
                const kidnapper1 = scene.userData.kidnapper1;
                const kidnapper2 = scene.userData.kidnapper2;
                const door = van.userData.door;
                const brakeLeft = van.userData.brakeLeft;
                const brakeRight = van.userData.brakeRight;
                const steam = scene.userData.steam;

                // Enable head bob for walking
                headBobEnabled = true;
                headBobIntensity = 0.7;
                headBobSpeed = 0.9;

                const duration = 9000;
                const startTime = Date.now();
                let hasShakenJump = false;
                let hasFlashedGrab = false;

                function animateKidnapping() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Animate steam rising
                    if (steam) {
                        steam.rotation.y = elapsed * 0.0005;
                        steam.position.y = 1.5 + Math.sin(elapsed * 0.001) * 0.3;
                    }

                    // Phase 1: Walking forward (0-2.5s) - Extended and smoother
                    if (elapsed < 2500) {
                        const walkProgress = elapsed / 2500;
                        const eased = easeInOutCubic(walkProgress);
                        camera.position.z = -eased * 4;
                        camera.lookAt(2.5, 1.7, camera.position.z - 10);
                    }

                    // Phase 2: Van approaches from behind (2.5-5.5s) - Smoother acceleration
                    if (elapsed >= 2500 && elapsed < 5500) {
                        const vanProgress = (elapsed - 2500) / 3000;
                        const eased = easeInOutQuart(vanProgress);

                        // Van drives up from behind and moves alongside
                        van.position.z = 25 - eased * 32;
                        van.position.x = -5 + eased * 2.5;

                        // Player continues walking but slower (noticing van)
                        const walkEased = easeOutQuart(vanProgress);
                        camera.position.z = -4 - walkEased * 1.5;

                        // Gradual head turn toward van
                        const turnStart = 2.5;
                        if (vanProgress > turnStart / 3) {
                            const turnProgress = Math.min((vanProgress - turnStart / 3) / (1 - turnStart / 3), 1);
                            const turnEased = easeInOutCubic(turnProgress);
                            const lookX = 2.5 - turnEased * 6;
                            const lookZ = camera.position.z - 10 + turnEased * 6;
                            camera.lookAt(lookX, 1.7, lookZ);
                        } else {
                            camera.lookAt(2.5, 1.7, camera.position.z - 10);
                        }
                    }

                    // Phase 3: Van stops, brake lights, door opens (5.5-7s)
                    if (elapsed >= 5500 && elapsed < 7000) {
                        headBobEnabled = false;
                        const stopProgress = (elapsed - 5500) / 1500;
                        const stopEased = easeOutQuart(stopProgress);

                        // Van decelerates smoothly
                        if (stopProgress < 0.4) {
                            const decelEased = easeOutQuart(stopProgress / 0.4);
                            van.position.z = -7 - decelEased * 4;
                            van.position.x = -2.5;
                        } else {
                            van.position.z = -11;
                            van.position.x = -2.5;

                            // Brake lights on
                            if (brakeLeft && brakeRight) {
                                brakeLeft.material.emissiveIntensity = 1.5;
                                brakeRight.material.emissiveIntensity = 1.5;
                            }
                        }

                        // Player stops walking, slight backward step
                        const playerStopEased = easeOutQuart(Math.min(stopProgress / 0.3, 1));
                        camera.position.z = -5.5 + playerStopEased * 0.3;

                        // Camera focuses on van
                        const lookEased = easeInOutCubic(stopProgress);
                        camera.lookAt(-2.5, 1.5, -11);

                        // Slide door open (smooth)
                        if (stopProgress > 0.4) {
                            const doorProgress = Math.min((stopProgress - 0.4) / 0.6, 1);
                            const doorEased = easeOutQuart(doorProgress);
                            door.position.x = 1.3 + doorEased * 1.6;
                        }
                    }

                    // Phase 4: Kidnappers jump out (7-8s) - More realistic movement
                    if (elapsed >= 7000 && elapsed < 8000) {
                        const jumpProgress = (elapsed - 7000) / 1000;
                        const eased = easeOutQuart(jumpProgress);

                        // Intense shake as they jump out
                        if (!hasShakenJump) {
                            shake(2.5, 0.2);
                            hasShakenJump = true;
                        }

                        // Make kidnappers visible
                        kidnapper1.visible = true;
                        kidnapper2.visible = true;

                        // Kidnappers jump out with realistic arc
                        const jumpHeight = Math.sin(Math.min(jumpProgress * 2, 1) * Math.PI) * 0.4;

                        kidnapper1.position.set(
                            -2.5 + eased * 3.5,
                            jumpHeight,
                            -11 + eased * 6
                        );

                        kidnapper2.position.set(
                            -2.5 + eased * 4.2,
                            jumpHeight * 0.9,
                            -11.5 + eased * 6.3
                        );

                        // Both face toward player
                        kidnapper1.lookAt(camera.position.x, 1, camera.position.z);
                        kidnapper2.lookAt(camera.position.x, 1, camera.position.z);

                        // Slight camera recoil and tilt
                        camera.rotation.z = Math.sin(jumpProgress * Math.PI) * 0.1;
                        if (jumpProgress > 0.3) {
                            const recoilProgress = (jumpProgress - 0.3) / 0.7;
                            const recoilEased = Math.sin(recoilProgress * Math.PI);
                            camera.position.z = -5.2 + recoilEased * 0.15;
                        }
                    }

                    // Phase 5: Kidnappers grab player (8-8.8s) - Faster, more intense
                    if (elapsed >= 8000 && elapsed < 8800) {
                        const grabProgress = (elapsed - 8000) / 800;
                        const eased = easeInQuart(grabProgress);

                        // Flash on grab
                        if (!hasFlashedGrab) {
                            flash(40);
                            hasFlashedGrab = true;
                        }

                        // Kidnappers rush toward player with acceleration
                        kidnapper1.position.set(
                            1 + eased * 1.5,
                            0,
                            -5 - eased * 0.5
                        );

                        kidnapper2.position.set(
                            1 + eased * 1.8,
                            0,
                            -5.2 - eased * 0.3
                        );

                        kidnapper1.lookAt(camera.position);
                        kidnapper2.lookAt(camera.position);

                        // Camera struggle - violent shaking and rotation
                        if (grabProgress > 0.1) {
                            const struggleProgress = (grabProgress - 0.1) / 0.9;
                            camera.rotation.x = Math.sin(struggleProgress * Math.PI * 12) * 0.6;
                            camera.rotation.z = Math.sin(struggleProgress * Math.PI * 10) * 0.7;
                            camera.position.y = 1.7 - Math.pow(struggleProgress, 2) * 0.8;

                            // Intense shake
                            shake(10, 0.05);
                        }
                    }

                    // Phase 6: Pulled into van / blackout (8.8-9s)
                    if (elapsed >= 8800) {
                        const blackoutProgress = Math.min((elapsed - 8800) / 100, 1);
                        const pullEased = easeInQuart(blackoutProgress);

                        // Camera pulled toward van violently
                        camera.position.x = 2.5 - pullEased * 4;
                        camera.position.z = -5.2 + pullEased * 5.8;
                        camera.position.y = 0.9 - pullEased * 0.5;
                        camera.rotation.x = pullEased * Math.PI * 0.4;
                        camera.rotation.z = pullEased * Math.PI * 0.3;

                        // Fast fade to black
                        blackout.style.transition = 'opacity 0.1s';
                        blackout.style.opacity = pullEased;
                    }

                    if (progress < 1) {
                        requestAnimationFrame(animateKidnapping);
                    }
                }

                animateKidnapping();

                // Final blackout
                setTimeout(() => {
                    blackout.style.opacity = '1';
                }, 8800);

                // Cleanup and resolve
                setTimeout(() => {
                    headBobEnabled = false;
                    camera.rotation.set(0, 0, 0);
                    resolve();
                }, duration);
            });
        }

        function runHallwayChase() {
            return new Promise(resolve => {
                buildHallwayScene();

                // Fade in from black (waking up after kidnapping)
                blackout.style.transition = 'opacity 1.5s ease-out';
                blackout.style.opacity = '0';

                // Start music immediately when hallway scene begins
                bgMusic.currentTime = 0;
                bgMusic.play();

                headBobEnabled = true;
                headBobIntensity = 1.2;
                headBobSpeed = 1.3;
                
                const door = scene.userData.door;
                const chaser = scene.userData.chaser;
                
                // Animate toward door
                const startZ = camera.position.z;
                const endZ = -19;
                const duration = 4500;
                const startTime = Date.now();
                
                function animateHallway() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 2);
                    
                    camera.position.z = startZ + (endZ - startZ) * eased;
                    camera.lookAt(0, 1.7, -22);
                    
                    // Chaser follows and gets closer
                    if (chaser) {
                        chaser.position.z = camera.position.z + 8 - progress * 4;
                    }
                    
                    // Door light intensifies as we approach
                    if (door) {
                        const doorLight = door.children.find(c => c.type === 'PointLight');
                        if (doorLight) {
                            doorLight.intensity = 2 + progress * 3;
                        }
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateHallway);
                    }
                }
                animateHallway();
                
                // Door burst - cleaner transition
                setTimeout(() => {
                    headBobEnabled = false;
                    doorSound.play();
                    
                    // Flash white as we hit the door
                    flashOverlay.style.transition = 'none';
                    flashOverlay.style.opacity = '1';
                    
                    shake(2.5, 0.5);
                }, 4200);
                
                // Hold white flash briefly, then fade through to forest
                setTimeout(() => {
                    // Keep flash white during scene transition
                    flashOverlay.style.transition = 'opacity 0.6s ease-out';
                }, 4400);
                
                setTimeout(() => {
                    // Fade flash out (forest will be built underneath)
                    flashOverlay.style.opacity = '0';
                }, 4600);
                
                setTimeout(resolve, 4500);
            });
        }
        
        function runForestRun() {
            return new Promise(resolve => {
                buildForestScene();
                
                // Slight delay before starting run (disorientation moment)
                setTimeout(() => {
                    headBobEnabled = true;
                    headBobIntensity = 1.5;
                    headBobSpeed = 1.5;
                }, 300);
                
                // Run through forest
                const duration = 4700;
                const startTime = Date.now();
                
                function animateForest() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    camera.position.z = -progress * 15;
                    camera.lookAt(0, 1.7, camera.position.z - 10);
                    
                    // Entity in background follows
                    const entity = scene.userData.entity;
                    if (entity) {
                        entity.position.z = 15 - progress * 5;
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateForest);
                    }
                }
                animateForest();
                
                // Panic blackouts (confusion in the forest)
                setTimeout(() => triggerBlackout(80), 1200);
                setTimeout(() => triggerBlackout(100), 2500);
                setTimeout(() => triggerBlackout(70), 3800);
                
                setTimeout(resolve, 5000);
            });
        }
        
        function runLookback() {
            return new Promise(resolve => {
                buildLookbackScene();
                headBobEnabled = false;
                
                const entity = scene.userData.entity;
                
                // Entity approaches
                setTimeout(() => {
                    roarSound.play();
                    if (entity) {
                        const startZ = entity.position.z;
                        const endZ = -1.5;
                        const duration = 800;
                        const startTime = Date.now();
                        
                        function lungeAnim() {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            const eased = progress * progress;
                            
                            entity.position.z = startZ + (endZ - startZ) * eased;
                            
                            if (progress < 1) {
                                requestAnimationFrame(lungeAnim);
                            }
                        }
                        lungeAnim();
                    }
                    shake(1.5, 0.8);
                }, 1500);
                
                setTimeout(resolve, 2500);
            });
        }
        
        function runFall() {
            return new Promise(resolve => {
                screamSound.play();
                
                // Tumbling camera
                const duration = 1500;
                const startTime = Date.now();
                
                function tumble() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    camera.rotation.x = progress * Math.PI * 0.5;
                    camera.rotation.z = Math.sin(progress * Math.PI * 3) * 0.5;
                    camera.position.y = 1.7 - progress * 1.4;
                    
                    if (progress < 1) {
                        requestAnimationFrame(tumble);
                    }
                }
                tumble();
                
                // Impact
                setTimeout(() => {
                    flash(200);
                    shake(3, 0.6);
                }, 1300);
                
                setTimeout(resolve, 1500);
            });
        }
        
        function runEntityAttack() {
            return new Promise(resolve => {
                buildGroundScene();
                
                const entity = scene.userData.entity;
                
                // Entity emerges
                if (entity) {
                    entity.visible = false;
                    setTimeout(() => {
                        entity.visible = true;
                    }, 800);
                }
                
                // Entity lunges at camera
                setTimeout(() => {
                    roarSound.currentTime = 0;
                    roarSound.play();
                    shake(2.5, 0.6);
                    
                    if (entity) {
                        const duration = 600;
                        const startTime = Date.now();
                        const startZ = entity.position.z;
                        const startScale = entity.scale.x;
                        
                        function attackAnim() {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            const eased = progress * progress * progress;
                            
                            entity.position.z = startZ + 3 * eased;
                            const scale = startScale + 3 * eased;
                            entity.scale.set(scale, scale, scale);
                            
                            if (progress < 1) {
                                requestAnimationFrame(attackAnim);
                            }
                        }
                        attackAnim();
                    }
                }, 2000);
                
                setTimeout(() => {
                    flash(80);
                }, 2500);
                
                setTimeout(resolve, 2600);
            });
        }
        
        function runBloodScene() {
            return new Promise(resolve => {
                // Red flash
                bloodOverlay.style.transition = 'opacity 0.2s';
                bloodOverlay.style.opacity = '1';
                
                // Fade to black
                setTimeout(() => {
                    blackout.style.transition = 'opacity 1.5s ease-in';
                    blackout.style.opacity = '1';
                }, 2500);
                
                setTimeout(() => {
                    bloodOverlay.style.opacity = '0';
                    blackout.style.transition = 'opacity 1s';
                    blackout.style.opacity = '0';
                    resolve();
                }, 4000);
            });
        }
        
        function runTitleReveal() {
            return new Promise(resolve => {
                buildTitleScene();
                titleContainer.classList.add('visible');
                
                // Letters slam down
                const timings = [200, 350, 500, 650, 800, 1100];
                letters.forEach((letter, i) => {
                    setTimeout(() => {
                        letter.classList.add('visible');
                        shake(1.2, 0.25);
                    }, timings[i]);
                });
                
                // Studio credit
                setTimeout(() => {
                    studio.classList.add('visible');
                }, 1500);
                
                // Final fade
                setTimeout(() => {
                    blackout.style.transition = 'opacity 3s ease-in';
                    blackout.style.opacity = '1';
                }, 5000);
                
                setTimeout(resolve, 8000);
            });
        }
        
        // ==================== START ====================
        
        document.getElementById('startScreen').addEventListener('click', startIntro);
        document.addEventListener('keydown', (e) => {
            if (!introStarted && (e.key === 'Enter' || e.key === ' ')) startIntro();
            if (introStarted && e.key === 'Escape') skipIntro();
        });
        
        function startIntro() {
            if (introStarted) return;
            introStarted = true;

            document.getElementById('startScreen').classList.add('hidden');

            // Music will start 1.5s after hallway scene begins
            runIntro();
        }
        
        function skipIntro() {
            bgMusic.pause();
            blackout.style.transition = 'opacity 0.5s';
            blackout.style.opacity = '1';
            setTimeout(() => {
                location.reload();
            }, 500);
        }
        
        // Initialize
        init();
    </script>
</body>
</html>
